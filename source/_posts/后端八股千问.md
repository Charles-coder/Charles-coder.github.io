---
title: 后端八股千问
date: 2023-09-4 10:39:41
tags: #后端开发 #SpringBoot
keywords: "JAVA，面经"
description: 每日20题！！！一千零一个java八股文

ai:
  - 本教程介绍了JAVA面试中常问的问题
---

9-24

**1.**什么是**Java**？

**2.Java**语言有哪些特点？

**3.JVM**、**JDK** 和 **JRE** 有什么区别？

**4.**说说什么是跨平台性？原理是什么**?**

**5.**什么是字节码？采用字节码的好处是什么**?**

**6.**为什么说 **Java** 语言**“**编译与解释并存**”**？

**7.Java**有哪些数据类型？

**8.**自动类型转换、强制类型转换？看看这几行代码？

**9.**什么是自动拆箱**/**封箱？

**10.&**和**&&**有什么区别？

**11.switch** 是否能作用在 **byte/long/String**上？

**12.break ,continue ,return** 的区别及作用？

**13.**用最有效率的方法计算**2**乘以**8**？

**14.**说说**自增自减**运算？看下这几个代码运行结果？

```
int i = 1;
i = i++;
System.out.println(i);
//1
```

**15.**⾯向对象和⾯向过程的区别?****

**16.**面向对象有哪些特性**?**

**17.**重载（**overload**）和重写（**override**）的区别？

**18.**访问修饰符**public**、**private**、**protected**、以及不写（默认）时的

区别？

**19.this**关键字有什么作用？

**20.**抽象类**(abstract class)**和接口**(interface)**有什么区别？





# 三、高并发

1.并行与并发的区别

2.什么是进程和线程

进程：系统进行资源分配调度的基本单位

线程：是进程的一个执行路径，一个进程至少有一个线程，同一一进程多个线程共享进程的资源

操作系统分配资源是给进程的，cpu资源是给现成的，比如启动main函数，就是启动了一个JVM进程，main函数就是一个主线程

**3.**说说线程有几种创建方式？

 继承Thread类，重写run方法，调用start（）

实现runnable接口，重写run方法

实现Callable接口，重写call方法

**4.**为什么调用**start()**方法时会执行**run()**方法，那怎么不直接调用

**run()**方法？

JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果

为什么我们不能直接调用**run()**方法？也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果

**5.**线程有哪些常用的调度方法？

![image-20231021211209937](https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021211209937.png)

Thread类也提供了一个方法用于等待的方法：

​	join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。

sleep(long millis) :线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。

**6.**线程有几种状态？

![image-20231021213135931](https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021213135931.png)



![image-20231021213213839](https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021213213839.png)

**7.**什么是线程上下文切换？

使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。

![image-20231021213402650](https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021213402650.png)

为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。

**8.**守护线程了解吗？

Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。

在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时，

JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出

**9.**线程间有哪些通信方式？

![image-20231021215725184](https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021215725184.png)

**volatile和synchronized关键字**

关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。

关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性

**等待/通知机制**

可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。

**管道输入/输出流**

管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。

**使用Thread.join()**

如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。

**使用ThreadLocal**

ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。

可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。

**10.ThreadLocal**是什么？

ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。

###  一、JAVA基础篇

#### 1.接口和抽象类的区别

相似点：

（1）接口和抽象类都不能被实例化

（2）实现接口或继承抽象类的普通子类都必须实现这些抽象方法

不同点：

（1）抽象类可以包含普通方法和代码块，接口里只能包含抽象方法，静态方法和默认方法，

（2）抽象类可以有构造方法，而接口没有

（3）抽象类中的成员变量可以是各种类型的，接口的成员变量只能是 **public static final** 类型的，并且必须赋值

#### 2.重载和重写的区别

重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同

重写发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写

#### 3.==和equals的区别

==比较基本类型，比较的是值，==比较引用类型，比较的是内存地址

equlas是Object类的方法，本质上与==一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是字符值，另外重写了equlas后，也必须重写hashcode()方法

#### 4.异常处理机制

（1）使用try、catch、finaly捕获异常，finaly中的代码一定会执行，捕获异常后程序会继续执行

（2）使用throws声明该方法可能会抛出的异常类型，出现异常后，程序终止

#### 5.HashMap原理

1.HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全

2.HashMap的扩容机制：

HashMap的默认容量为16，默认的负载因子为0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树

3.HashMap存取原理：

（1）计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置

（2）如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）

#### 6.想要线程安全的HashMap怎么办？

（1）使用ConcurrentHashMap

（2）使用HashTable

（3）Collections.synchronizedHashMap()方法

#### 7.ConcurrentHashMap原如何保证的线程安全？

JDK1.7:使用分段锁，将一个Map分为了16个段，每个段都是一个小的hashmap，每次操作只对其中一个段加锁

JDK1.8:采用CAS+Synchronized保证线程安全，每次插入数据时判断在当前数组下标是否是第一次插入，是就通过CAS方式插入，然后判断f.hash是否=-1，是的话就说明其他线程正在进行扩容，当前线程也会参与扩容；删除方法用了synchronized修饰，保证并发下移除元素安全

#### 8.HashTable与HashMap的区别

（1）HashTable的每个方法都用synchronized修饰，因此是线程安全的，但同时读写效率很低

（2）HashTable的Key不允许为null

（3）HashTable只对key进行一次hash，HashMap进行了两次Hash

（4）HashTable底层使用的数组加链表

#### 9.ArrayList和LinkedList的区别

 ArratList的底层使用动态数组，默认容量为10，当元素数量到达容量时，生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来；因为数组在内存中是连续的地址，所以ArrayList查找数据更快，由于扩容机制添加数据效率更低

LinkedList的底层使用链表，在内存中是离散的，没有扩容机制；LinkedList在查找数据时需要从头遍历，所以查找慢，但是添加数据效率更高

####  10.如何保证ArrayList的线程安全？

（1）使用collentions.synchronizedList（）方法为ArrayList加锁

（2）使用Vector，Vector底层与Arraylist相同，但是每个方法都由synchronized修饰，速度很慢

（3）使用juc下的CopyOnWriterArrayList，该类实现了读操作不加锁，写操作时为list创建一个副本，期间其它线程读取的都是原本list，写操作都在副本中进行，写入完成后，再将指针指向副本。

#### 11.String、StringBuffer、StringBuilder的区别

String 由 char[] 数组构成，使用了 final 修饰，对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象。

StringBuffer可变并且线程安全

StringBuiler可变但线程不安全。

操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。

#### **12.hashCode和equals**

 hashCode()和equals()都是Obkect类的方法，hashCode()默认是通过地址来计算hash码，但是可能被重写过用内容来计算hash码，equals()默认通过地址判断两个对象是否相等，但是可能被重写用内容来比较两个对象

所以两个对象相等，他们的hashCode和equals一定相等，但是hashCode相等的两个对象未必相等

如果重写equals()必须重写hashCode()，比如在HashMap中，key如果是String类型，String如果只重写了equals（）而没有重写hashcode（）的话，则两个equals()比较为true的key，因为hashcode不同导致两个key没有出现在一个索引上，就会出现map中存在两个相同的key

#### 13.面向对象和面向过程的区别

面向对象有封装、继承、多态性的特性，所以相比面向过程易维护、易复用、易扩展，但是因为类调用时要实例化，所以开销大性能比面向过程低

####  4.深拷贝和浅拷贝

浅拷贝:浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存
深拷贝:深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。

#### 15.多态的作用

多态的实现要有继承、重写，父类引用指向子类对象。它的好处是可以消除类型之间的耦合关系，增加类的可扩充性和灵活性。

#### 16.什么是反射？

反射是通过获取类的class对象，然后动态的获取到这个类的内部结构，动态的去操作类的属性和方法。
应用场景有：要操作权限不够的类属性和方法时、实现自定义注解时、动态加载第三方jar包时、按需加载类，节省编译和初始化时间；
获取class对象的方法有：class.forName(类路径)，类.class()，对象的getClass（）

#### 17.Java创建对象得五种方式?

(1)new关键字  (2)Class.newInstance (3)Constructor.newInstance

(4)Clone方法  (5)反序列化

### 二.Java多线程篇

#### 1.进程和线程的区别，进程间如何通信

进程：系统运行的基本单位，进程在运行过程中都是相互独立，但是线程之间运行可以相互影响。

线程：独立运行的最小单位，一个进程包含多个线程且它们共享同一进程内的系统资源

进程间通过管道、 共享内存、信号量机制、消息队列通信

#### 2. 什么是线程上下文切换

当一个线程被剥夺cpu使用权时，切换到另外一个线程执行

####  3.什么是死锁

死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局

####  4.死锁的必要条件

互斥条件：同一资源同时只能由一个线程读取

不可抢占条件：不能强行剥夺线程占有的资源

请求和保持条件：请求其他资源的同时对自己手中的资源保持不放

循环等待条件：在相互等待资源的过程中，形成一个闭环

想要预防死锁，只需要破坏其中一个条件即可，比如使用定时锁、尽量让线程用相同的加锁顺序，还可以用银行家算法可以预防死锁 

#### 5.Synchrpnized和lock的区别

（1）synchronized是关键字，lock是一个类

（2） synchronized在发生异常时会自动释放锁，lock需要手动释放锁

（3）synchronized是可重入锁、非公平锁、不可中断锁，lock的ReentrantLock是可重入锁，可中断锁，可以是公平锁也可以是非公平锁

（4）synchronized是JVM层次通过监视器实现的，Lock是通过AQS实现的

#### 6.什么是AQS锁?

AQS是一个抽象类，可以用来构造锁和同步类，如ReentrantLock，Semaphore，CountDownLatch，CyclicBarrier。

AQS的原理是，AQS内部有三个核心组件，一个是state代表加锁状态初始值为0，一个是获取到锁的线程，还有一个阻塞队列。当有线程想获取锁时，会以CAS的形式将state变为1，CAS成功后便将加锁线程设为自己。当其他线程来竞争锁时会判断state是不是0，不是0再判断加锁线程是不是自己，不是的话就把自己放入阻塞队列。这个阻塞队列是用双向链表实现的

可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。

**7.为什么AQS使用的双向链表？**

因为有一些线程可能发生中断 ，而发生中断时候就需要在同步阻塞队列中删除掉，这个时候用双向链表方便删除掉中间的节点

#### 8.有哪些常见的AQS锁

AQS分为独占锁和共享锁

**ReentrantLock（独占锁）**：可重入，可中断，可以是公平锁也可以是非公平锁，非公平锁就是会通过两次CAS去抢占锁，公平锁会按队列顺序排队

**Semaphore（信号量）**:设定一个信号量，当调用acquire()时判断是否还有信号，有就获取一个信号量，没有就阻塞等待其他线程释放信号量，当调用release()时释放一个信号量，唤醒阻塞线程。

应用场景：允许多个线程访问某个临界资源时，如上下车，买卖票

**CountDownLatch（倒计数器）**:给计数器设置一个初始值，当调用CountDown()时计数器减一，当调用await() 时判断计数器是否归0，不为0就阻塞，直到计数器为0。

应用场景：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行

**CyclicBarrier（循环栅栏）**:给计数器设置一个目标值,当调用await() 时会计数+1并判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值

应用场景：多线程计算数据，最后合并计算结果的应用场景

**9.sleep()和wait()的区别**

 (1)wait()是Object的方法，sleep()是Thread类的方法

(2)wait()会释放锁，sleep()不会释放锁

(3)wait()要在同步方法或者同步代码块中执行，sleep()没有限制

(4)wait()要调用notify()或notifyall()唤醒,sleep()自动唤醒

#### 10.yield()和join()区别

yield()调用后线程进入就绪状态

A线程中调用B线程的join() ,则B执行完前A进入阻塞状态

#### 11.线程池七大参数

核心线程数：线程池中的基本线程数量

最大线程数：当阻塞队列满了之后，逐一启动

最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间

最大线程的存活时间单位

阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列

线程工厂：用于生产线程

任务拒绝策略：阻塞队列满后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争

#### 12.Java内存模型 

JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取

具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的

由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题

#### 13.保证并发安全的三大特性？

 原子性：一次或多次操作在执行期间不被其他线程影响

可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道

有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排

####  14.volatile

保证变量的可见性和有序性，不保证原子性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。


单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：为实例对象分配内存，用构造器初始化成员变量，将实例对象引用指向分配的内存；实例对象在分配内存后实才不为null。如果分配内存后还未初始化就先将实例对象指向了内存，那么此时最外层的if会判断实例对象已经不等于null就直接将实例对象返回。而此时初始化还没有完成。

#### 15.线程使用方式

(1)继承 Tread 类

(2)实现 Runnable 接口

(3)实现 Callable 接口：带有返回值

(4)线程池创建线程

#### 16.ThreadLocal原理

原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。
但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value

#### 17.什么是CAS锁

CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是

（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作 

（2）CAS频繁失败导致CPU开销大

（3）ABS问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决

#### 18.Synchronized锁原理和优化

Synchronize是通过对象头的markwordk来表明监视器的，监视器本质是依赖操作系统的互斥锁实现的。操作系统实现线程切换要从用户态切换为核心态，成本很高，此时这种锁叫重量级锁，在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁

偏向锁：当一段代码没有别的线程访问，此时线程去访问会直接获取偏向锁

轻量级锁：当锁是偏向锁时，有另外一个线程来访问，会升级为轻量级锁。线程会通过CAS方式获取锁，不会阻塞，提高性能，

重量级锁：轻量级锁自旋一段时间后线程还没有获取到锁，会升级为重量级锁，重量级锁时，来竞争锁的所有线程都会阻塞，性能降低

注意，锁只能升级不能降级

#### 19.如何根据 CPU 核心数设计线程池线程数量

IO 密集型：线程中十分消耗Io的线程数*2
CPU密集型： cpu线程数量

#### 20.AtomicInteger的使用场景

AtomicInteger是一个提供原子操作的Integer类，使用CAS+volatile实来现线程安全的数值操作。

因为volatile禁止了jvm的排序优化,所以它不适合在并发量小的时候使用，只适合在一些高并发程序中使用



### 三.JVM篇

#### 1.JVM运行时数据区（内存结构）

线程私有区：

（1）虚拟机栈：每次调用方法都会在虚拟机栈中产生一个栈帧，每个栈帧中都有方法的参数、局部变量、方法出口等信息，方法执行完毕后释放栈帧

（2）本地方法栈：为native修饰的本地方法提供的空间，在HotSpot中与虚拟机合二为一

（3）程序计数器：保存指令执行的地址，方便线程切回后能继续执行代码

线程共享区：

（4）堆内存：Jvm进行垃圾回收的主要区域，存放对象信息，分为新生代和老年代，内存比例为1：2，新生代的Eden区内存不够时时发生MinorGC,老年代内存不够时发生FullGC

（5）方法区：存放类信息、静态变量、常量、运行时常量池等信息。JDK1.8之前用持久代实现，JDK1.8后用元空间实现，元空间使用的是本地内存，而非在JVM内存结构中

#### 2.什么情况下会内存溢出？

堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时

栈溢出：方法调用次数过多，一般是递归不当造成

#### 3.JVM有哪些垃圾回收算法？

（1）标记清除算法： 标记不需要回收的对象，然后清除没有标记的对象，会造成许多内存碎片。
（2）复制算法： 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。用在新生代
（3）标记整理算法： 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。用在老年代

#### **4.GC如何判断对象可以被回收？**

（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题

（2）可达性分析法：从GCRoot开始往下搜索，搜索过的路径称为引用链，若一个对象GCRoot没有任何的引用链，则判定可以回收

 GCRoot有：虚拟机栈中引用的对象，方法区中静态变量引用的对象，本地方法栈中引用的对象

#### 5.典型垃圾回收器

CMS:以最小的停顿时间为目标、只运行在老年代的垃圾回收器，使用标记-清除算法，可以并发收集。

G1 ：JDK1.9以后的默认垃圾回收器，注重响应速度，支持并发，采用标记整理+复制算法回收内存，使用可达性分析法来判断对象是否可以被回收。

#### 6.类加载器和双亲委派机制

从父类加载器到子类加载器分别为：

BootStrapClassLoader  加载路径为：JAVA_HOME/jre/lib

ExtensionClassLoader  加载路径为：JAVA_HOME/jre/lib/ext

ApplicationClassLoader 加载路径为：classpath

还有一个自定义类加载器

当一个类加载器收到类加载请求时，会先把这个请求交给父类加载器处理，若父类加载器找不到该类，再由自己去寻找。该机制可以避免类被重复加载，还可以避免系统级别的类被篡改

#### 7.JVM中有哪些引用？

强引用：new的对象。哪怕内存溢出也不会回收

软引用：只有内存不足时才会回收

弱引用：每次垃圾回收都会回收

虚引用：必须配合引用队列使用，一般用于追踪垃圾回收动作

#### 8.类加载过程

（1）加载 ：把字节码通过二进制的方式转化到方法区中的运行数据区

（2）连接：

 验证：验证字节码文件的正确性。

 准备：正式为类变量在方法区中分配内存，并设置初始值，final类型的变量在编译时已经赋值了

 解析：将常量池中的符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址） 

（3）初始化 ：执行类构造器（不是常规的构造方法），为静态变量赋初值并初始化静态代码块。

#### 9.JVM类初始化顺序

父类静态代码块和静态成员变量->子类静态代码块和静态成员变量->父类代码块和普通成员变量->父类构造方法->子类代码块和普成员变量->子类构造方法

#### 10..对象的创建过程

（1）检查类是否已被加载，没有加载就先加载类

（2）为对象在堆中分配内存，使用CAS方式分配，防止在为A分配内存时，执行当前地址的指针还没有来得及修改，对象B就拿来分配内存。

（3）初始化，将对象中的属性都分配0值或null

（4）设置对象头

（5）为属性赋值和执行构造方法

#### 11.对象头中有哪些信息

对象头中有两部分，一部分是MarkWork,存储对象运行时的数据，如对象的hashcode、GC分代年龄、GC标记、锁的状态、获取到锁的线程ID等；另外一部分是表明对象所属类，如果是数组，还有一个部分存放数组长度

#### 12.JVM内存参数

-Xmx[]:堆空间最大内存

-Xms[]:堆空间最小内存，一般设置成跟堆空间最大内存一样的

-Xmn[]:新生代的最大内存

-xx:[survivorRatio=3]:eden区与from+to区的比例为3：1，默认为4：1

-xx[use 垃圾回收器名称]：指定垃圾回收器

-xss:设置单个线程栈大小

一般设堆空间为最大可用物理地址的百分之80

#### 13.GC的回收机制和原理

GC的目的实现内存的自动释放，使用可达性分析法判断对象是否可回收，采用了分代回收思想，
将堆分为新生代、老年代，新生代中采用复制算法，老年代采用整理算法，当新生代内存不足时会发生minorGC,老年代不足时会发送fullGC

### 四.Mysql篇

#### 1.MyIsAm和InnoDB的区别

InnoDB有三大特性，分别是事务、外键、行级锁，这些都是MyIsAm不支持的，

另外InnoDB是聚簇索引，MyIAm是非聚簇索引，

InnoDB不支持全文索引，MyIAm支持

InnoDB支持自增和MVCC模式的读写，MyIAm不支持

MyIsAM的访问速度一般InnoDB快，差异在于innodb的mvcc、行锁会比较消耗性能，还可能有回表的过程（先去辅助索引中查询数据，找到数据对应的key之后，再通过key回表到聚簇索引树查找数据）

#### 2.mysql事务特性

原子性：一个事务内的操作统一成功或失败

一致性：事务前后的数据总量不变

隔离性：事务与事务之间相互不影响

持久性：事务一旦提交发生的改变不可逆

#### 3.事务靠什么保证

原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql

一致性：由其他三大特性共同保证，是事务的目的

隔离性：由MVCC保证

持久性：由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复

#### 4.事务的隔离级别

在高并发情况下，并发事务会产生脏读、不可重复读、幻读问题，这时需要用隔离级别来控制

读未提交： 允许一个事务读取另一个事务已提交的数据，可能出现不可重复读，幻读。

读提交：  只允许事务读取另一个事务没有提交的数据可能出现不可重复读，幻读。

可重复读： 确保同一字段多次读取结果一致，可能出现欢幻读。

可串行化： 所有事务逐次执行，没有并发问日

Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过间隙锁解决了幻读问题。

#### 5.什么是快照读和当前读

*快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照都

*当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读

#### 6.MVCC是什么

MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突，这种读叫做快照读。只在读已提交和可重复读中生效。

实现原理由四个东西保证，他们是

undolog日志：记录了数据历史版本

readView:事务进行快照读时动态生成产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见

隐藏字段DB_TRC_ID： 最近修改记录的事务ID 

隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本

#### 7.MySQL有哪些索引

主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值

唯一索引：唯一索引不能有相同值，但允许为空

普通索引：允许出现重复值

组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则

全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎

#### 8.聚簇索引和非聚簇索引的区别

聚簇索引：聚簇索引的叶子节点存放的是主键值和数据行；辅助索引（在聚簇索引上创建的其它索引）的叶子节点存放的是主键值或指向数据行的指针。

优点：根据索引可以直接获取值，所以他获取数据更快；对于主键的排序查找和范围查找效率更高；

缺点：如果主键值很大的话，辅助索引也会变得很大；如果用uuid作为主键，数据存储会很稀疏；修改主键或乱序插入会让数据行移动导致页分裂；所以一般我们定义主键时尽量让主键值小，并且定义为自增和不可修改。

非聚簇索引（辅助索引）：叶子节点存放的是数据行地址，先根据索引找到数据地址，再根据地址去找数据

他们都是b+数结构

#### 9.MySQL如何做慢SQL优化

可以查看执行计划分析数据的扫描类型、索引是否生效，常见的慢查询优化有：

（1）尽量减少select的数据列，尽量使用覆盖索引

（2）orderby查找时使用索引进行排序，否则的话需要进行回表

（3）groupby查询时，同样要用索引，避免使用到临时表

（4）分页查询时，如果limit 后面的数字太大，可以使用子查询查出主键，再limit主键后n条数据就能走覆盖索引

（5） 使用复杂查询时，使用关联查询来代替子查询，并且最好使用内连接

（6）使用count函数时直接使用count的话count(*)的效率最高

count(*)或count(唯一索引)或count(数字):表中总记录数，count(字段)不会统计null

 (7) 在写update语句时，where条件要使用索引，否则会锁会从行锁升级为表锁

（8）表中数据是否太大，是不是要分库分表

#### 10.为什么要用内连接而不用外连接？

用外连接的话连接顺序是固定死的，比如left join，他必须先对左表进行全表扫描，然后一条条到右表去匹配；而内连接的话mysql会自己根据查询优化器去判断用哪个表做驱动。

子查询的话同样也会对驱动表进行全表扫描，所以尽量用小表做驱动表。

#### 11.MySQL整个查询的过程

（1）客户端向 MySQL 服务器发送一条查询请求
（2）服务器首先检查查询缓存，如果命中缓存，则返回存储在缓存中的结果。否则进入下一阶段
（3）服务器进行 SQL 解析、预处理、再由优化器生成对应的执行计划
（4）MySQL 根据执行计划，调用存储引擎的 API 来执行查询
（5）将结果返回给客户端，同时缓存查询结果
注意：只有在8.0之前才有查询缓存，8.0之后查询缓存被去掉了

#### 12.执行计划中有哪些字段？

我们想看一个sql的执行计划使用的语句是explain+SQL，表中的字段包括：

**type**:扫描类型，效率从底到高为ALL（全表扫描)>index(全索引扫描，我们的需要的数据在索引中可以获取)>range(使用索引进行范围查找)>ref(使用非唯一索引列进行了关联查询)> eq_ref (使用唯一索引进行关联查询)>const(使用唯一索引查询一行数据)>system(表中只有一行数据)

 **extra（额外的）**:mysql如何查询额外信息，常见的有：

filesort:在排序缓冲区中进行排序，需要回表查询数据

index:表示使用覆盖索引

index scan:排序时使用了索引排序，但如果是按照降序排序的话就会使用反向扫描索引

temporary:查询时要建立一个临时表存放数据

**rows**:找到了多少行数据

**key**:实际使用到的索引

**id**:select查询的优先级，id越大优先级越高，子查询的id一般会更大

**select_type**:查询的类型,是普通查询还是联合查询还是子查询，常见类型有simple（不包含子查询），primary（标记复杂查询中最外层的查询），union(标记primart只后子查询)

**table**：者一行的数据是数哪张表的

**possible_keys（可能的）:**当前查询语句可能用到的索引，可能为null(如果用了索引但是为null有可能是表数据太少innodb认为全表扫描更快)

**ref（编号）:**显示索引的哪一行被使用了

#### 13.哪些情况索引会失效

（1）where条件中有or，除非所有查询条件都有索引，否则失效

（2）like查询用%开头，索引失效

（3）索引列参与计算，索引失效

（4）违背最左匹配原则，索引失效

（5）索引字段发生类型转换，索引失效

（6）mysql觉得全表扫描更快时（数据少），索引失效

#### 14.B和B+数的区别，为什么使用B+数

二叉树：索引字段有序，极端情况会变成链表形式

AVL数：树的高度不可控

B数：控制了树的高度，但是索引值和data都分布在每个具体的节点当中，若要进行范围查询，要进行多次回溯，IO开销大

B+树：非叶子节点只存储索引值，叶子节点再存储索引+具体数据，从小到大用链表连接在一起，范围查询可直接遍历不需要回溯7

#### 15.MySQL有哪些锁

基于粒度：

 *表级锁：对整张表加锁，粒度大并发小

 *行级锁：对行加锁，粒度小并发大

 *间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读

基于属性：

  *共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁

   *排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题  

#### 16.Mysql内连接、左连接、右连接的区别

内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分

#### 17.sql执行顺序



#### 18.如何设计数据库？

（1）抽取实体，如用户信息，商品信息，评论

（2）分析其中属性，如用户信息：姓名、性别...

（3）分析表与表之间的关联关系

然后可以参考三大范式进行设计，设计主键时，主键要尽量小并且定义为自增和不可修改。

#### 19.where和having的区别？

where是约束声明，having是过滤声明，where早于having执行，并且where不可以使用聚合函数，having可以

#### 20.三大范式

第一范式：每个列都不可以再拆分。

第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。

第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。

#### 21.char和varchar的区别

char是不可变的，最大长度为255，varchar是可变的字符串，最大长度为2^16

#### 22.InnoDB 什么情况下会产生死锁

事务1已经获取数据A的写锁，想要去获取数据B的写锁，然后事务2获取了B的写锁，想要去获取A的写锁，相互等待形成死锁。
mysql解决死锁的机制有两个：1.等待， 直到超时 2.发起死锁检测，主动回滚一条事务
死锁检测的原理是构建一个以事务为顶点、 锁为边的有向图， 判断有向图是否存在环， 存在即有死锁。
我们平时尽量减少事务操作的资源和隔离级别

#### 23.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？

innodb 引擎：
MySQL8.0前，下次自增会取表中最大 id + 1。原理是最大id会记录在内存中，重启之后会重新读取表中最大的id
MySQL8.0后，仍从删除数据 id 后算起。原理是它将最大id记录在redolog里了

myisam：
自增的 id 都从删除数据 id 后算起。原理是它将最大id记录到数据文件里了

#### 24.MySQL插入百万级的数据如何优化？

（1）一次sql插入多条数据，可以减少写redolog日志和binlog日志的io次数（sql是有长度限制的，但可以调整）

（2）保证数据按照索引进行有序插入

（3）可以分表后多线程插入



### 五.常用开发框架系列

#### 1.什么是Spring？

Spring是个轻量级的框架，通过IOC达到松耦合的目的，通过AOP可以分离应用业务逻辑和系统服务进行内聚性的开发，不过配置各种组件时比较繁琐，所以后面才出选了SpringBoot的框架。 

#### 2.IOC是什么？

IOC是控制反转，是一种思想，把对象的创建和调用从程序员手中交由IOC容器管理，降低对象之间的依赖关系。

创建一个bean的方式有xml方式、@Bean注解方式、@Componte方式

我们在对一个bean进行实例化后，要对他的属性进行填充，大多数我们都是使用 @Autowire直接的填充依赖注入的，他是有限按照类型进行匹配。

#### 3.AOP是什么？ 

AOP是面向切面编程，可以将那些与业务不相关但是很多业务都要调用的代码抽取出来，思想就是不侵入原有代码的情况下对功能进行增强。

SpringAOP是基于动态代理实现的，动态代理是有两种，一种是jdk动态代理，一种是cglib动态代理;

jdk动态代理是原理是利用反射来实现的，需要调用反射包下的Proxy类的newProxyInstance方法来返回代理对象，这个方法中有三个参数，分别是用于加载代理类的类加载器，被代理类实现的接口的class数组和一个用于增强方法的InvocaHandler实现类。

cglib动态代理原理是利用asm开源包来实现的，是把被代理类的class文件加载进来，通过修改它的字节码生成子类来处理

jdk动态代理要求被代理类必须有实现的接口，生成的动态代理类会和代理类实现同样的接口，cglib则，生成的动态代理类会继承被代理类。Spring默认使用jdk动态代理，当被代理的类没有接口时就使用cglib动态代理

#### 4.如何定义一个全局异常处理类？

想要定义一个全局异常处理类的话，我们需要在这个类上添加@ContaollerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上添加@ExceptionHandler(value = 异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理。

如果我们需要自定义异常的话，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息，再根据需求写构造方法； 

#### 5.如何使用aop自定义日志？

第一步：创建一个切面类，把它添加到ioc容器中并添加@Aspect注解

第二步： 在切面类中写一个通知方法，在方法上添加通知注解并通过切入点表达式来表示要对哪些方法进行日志打印，然后方法参数为JoinPoint

第三步：通过JoinPoint这个参数可以获取当前执行的方法名、方法参数等信息，这样就可以根据需求在方法进入或结束时打印日志

#### 6.循环依赖是什么，怎么解决的？

循环依赖就是在创建 A 实例的时候里面包含着 B 属性实例，所以这个时候就需要去创建 B 实例，而创 建 B 实例过程中也包含着 A 实例。 这样 A 实例还在创建的过程当中，所以就导致 A 和 B 实例都创建不出来。

spring通过三级缓存来解决循环依赖：

一级缓存：单例池，缓存经过了已经初始化完毕的Bean

二级缓存 ：半成品池，缓存还未初始化完毕的Bean

三级缓存：缓存的是获取Bean的代理对象的表达式

我们在创建 A 的过程中，先将 A 放入三级缓存 ，这时要创建B，B要创建A就直接去三级缓存中查找，并且判断需不需要进行 AOP 处理，如果需要就在三级缓存中获取A的代理对象，不需要就取A原始对象。然后将取出的对象放入二级缓存中，这个时候其他需要依赖 A 对象的直接从二级缓存中去获取即可。当B初始化完成进入一级缓存后，A 继续执行生命周期，当A完成了属性的注入后，就可以放入一级缓存了

spring2.6之前默认会解决循环依赖。在spring2.6之后需要通过配置开启解决循环依赖

#### 7.Bean 的作用域

（1）Singleton:一个IOC容器只有一个

（2）Prototype:每次调用getBean()都会生成一个新的对象

（3）request:每个http请求都会创建一个自己的bean

（4）session:同一个session共享一个实例

（5）application:整个serverContext只有一个bean

（6）webSocket:一个websocket只有一个bean

#### 8.Bean 生命周期

实例化 Instantiation->属性赋值 Populate->初始化 Initialization->销毁 Destruction
在这四步的基础上面，Spring 提供了一些拓展点：

*Bean 自身的方法: 包括了 Bean 本身调用的方法和通过配置文件中的 init-method 和 destroy-method 指定的方法
*Bean 级生命周期接口方法:包括了 BeanNameAware、BeanFactoryAware、InitializingBean 和 DiposableBean 这些接口的方法
*容器级生命周期接口方法:包括了 InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。
*工厂后处理器接口方法: 包括了 AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer 等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。

#### 9.Spring 事务原理？

spring事务有编程式和声明式，我们一般使用声明式，在某个方法上增加@Transactional注解，这个方法中的sql会统一成功或失败。

原理是：

当一个方法加上@Transactional注解，spring会基于这个类生成一个代理对象并将这个代理对象作为bean，当使用这个bean中的方法时，如果存在@Transactional注解，就会将事务自动提交设为false，然后执行方法，执行过程没有异常则提交，有异常则回滚、

#### 10.spring事务失效场景

（1）事务方法所在的类没有加载到容器中

（2）事务方法不是public类型

（3）同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效

（4）spring事务默认只回滚运行时异常，可以用rollbackfor属性设置

（5）业务自己捕获了异常，事务会认为程序正常秩序

#### 11.spring事务的隔离级别

default:默认级别，使用数据库自定义的隔离级别

其它四种隔离级别与mysql一样

#### 12.spring事务的传播行为

（1）支持当前事务，如果不存在，则新启一个事务

（2）支持当前事务，如果不存在，则抛出异常

（3）支持当前事务，如果不存在，则以非事务方式执行

（4）不支持当前事务，创建一个新事物

（5）不支持当前事务，如果已存在事务就抛异常

（6）不支持当前事务，始终以非事务方式执行

#### 13.Spring IoC

![20200904160557786.png](https://img-blog.csdnimg.cn/20200904160557786.png)

#### 12.spring用了哪些设计模式

BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式

#### 14.SpringMV工作原理

SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）

工作流程：

（1）DispatchServerlet接收用户请求将请求发送给HandleMapping

 （2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet

（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler

（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view

（5）DispatchServerlet根据view进行视图渲染，返回给用户

#### 15.springboot自动配置原理

在spring—boot—autoconfigura包下存放了spring内置的自动配置类和spring.factories文件，这个文件中存放了这些配置类的全类名 ；

启动类@SpringbootApplication注解下，有三个关键注解

（1）@springbootConfiguration:表示启动类是一个自动配置类

（2）@CompontScan:扫描启动类所在包下及子包的组件到容器中

（3）@EnableConfigutarion，下面有个子注解@Import会导入上面所说的自动配置类，这些配置类会根据元注解的装配条件生效，生效的类就会被实例化，加载到ioc容器中；这些自动配置类还会通过xxxProperties文件里配置来进行属性设值

#### 16 .springboot常用注解

@RestController          ：修饰类，该控制器会返回Json数据 

@RequestMapping("/path") ：修饰类，该控制器的请求路径

@Autowired             :  修饰属性，按照类型进行依赖注入

@PathVariable           :  修饰参数，将路径值映射到参数上

@ResponseBody         :修饰方法，该方法会返回Json数据

@RequestBody（需要使用Post提交方式） :修饰参数，将Json数据封装到对应参数中
@Controller@Service@Compont:  将类注册到ioc容器

@Transaction：开启事务

#### 17.spring的bean是线程安全的吗？

spring的默认bean作用域是单例的，单例的bean不是线程安全的，但是开发中大部分的bean都是无状态的，不具备存储功能，比如controller、service、dao，他们不需要保证线程安全。

如果要保证线程安全，可以将bean的作用域改为prototype，比如像Model View。

另外还可以采用**ThreadLocal**来解决线程安全问题。ThreadLocal为每个线程保存一个副本变量，每个线程只操作自己的副本变量。

#### 18.springcloud主要解决什么问题？

解决服务之间的通信、容灾、负载平衡、冗余问题，能方便服务集中管理，常用组件有注册中心、配置中心、远程调用。服务熔断、网关

#### 19.CAP理论

C：一致性，这里指的强一致性，也就是数据更新完，访问任何节点看到的数据完全一致

A：可用性，就是任何没有发生故障的服务必须在规定时间内返回合正确结果

P：容灾性，当网络不稳定时节点之间无法通信，造成分区，这时要保证系统可以继续正常服务。提高容灾性的办法就是把数据分配到每一个节点当中，所以P是分布式系统必须实现的，然后需要在C和A中取舍

#### 20.为什么不能同时保证一致性和可用性呢？

当网络发生故障时，如果要保障数据一致性，那么节点相互间就只能阻塞等待数据真正同步时再返回，就违背可用性了。如果要保证可用性，节点要在有限时间内将结果返回，无法等待其它节点的更新消息，此时返回的数据可能就不是最新数据，就违背了一致性了

#### 21.熔断限流的理解？ 

SprngCloud中用Hystrix组件来进行降级、熔断、限流

熔断是对于消费者来讲，当对提供者请求时间过久时为了不影响性能就对链接进行熔断，

限流是对于提供者来讲，为了防止某个消费者流量太大，导致其它更重要的消费者请求无法及时处理。限流可用通过拒绝服务、服务降级、消息队列延时处理、限流算法来实现

#### 22.常用限流算法

计数器算法：使用redis的setnx和过期机制实现

漏桶算法：一般使用消息队列来实现，系统以恒定速度处理队列中的请求，当队列满的时候开始拒绝请求。

令牌桶算法：计数器算法和漏桶算法都无法解决突然的大并发，令牌桶算法是预先往桶中放入一定数量token，然后用恒定速度放入token直到桶满为止，所有请求都必须拿到token才能访问系统

#### 

### 六.Redis系列

#### 1.redis为什么快？

（1）完全基于内存操作

（2）数据结构简单，对数据操作简单

（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题

 (4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器

其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。

#### 2.redis持久化机制

（1）快照持久化RDB

redis的默认持久化机制，通过父进程fork一个子进程，子进程将redis的数据快照写入一个临时文件，等待持久化完毕后替换上一次的rdb文件。整个过程主进程不进行任何的io操作。持久化策略可以通过save配置单位时间内执行多少次操作触发持久化。所以RDB的优点是保证redis性能最大化，恢复速度数据较快，缺点是可能会丢失两次持久化之间的数据

（2）追加持久化AOF

以日志形式记录每一次的写入和删除操作，策略有每秒同步、每次操作同步、不同步，优点是数据完整性高，缺点是运行效率低，恢复时间长

#### 3.Redis如何实现key的过期删除？

采用的定期过期+惰性过期

定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。
惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。

#### 4.Redis数据类型应用场景

String：可以用来缓存json信息，可以用incr命令实现自增或自减的计数器

Hash：与String一样可以保存json信息

List：可以用来做消息队列，list的pop是原子性操作能一定程度保证线程安全

Set：可以做去重，比如一个用户只能参加一次活动 ;可以做交集求共友

SortSet ：有序的。可以实现排行榜

#### 5.Redis缓存穿透如何解决？

缓存穿透是指频繁请求客户端和缓存中都不存在的数据，缓存永远不生效，请求都到达了数据库。

解决方案：

（1）在接口上做基础校验，比如id<=0就拦截

（2）缓存空对象：找不到的数据也缓存起来，并设置过期时间，可能会造成短期不一致

（3）布隆过滤器：在客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求

#### 6.Redis如何解决缓存击穿？

缓存击穿是值一个key非常热点，key在某一瞬间失效，导致大量请求到达数据库

解决方案：

（1）设置热点数据永不过期

（2）给缓存重建的业务加上互斥锁，缺点是性能低

#### 7.Redis如何解决缓存雪崩？

缓存雪崩是值某一时间Key同时失效或redis宕机，导致大量请求到达数据库

解决方案：

（1）搭建集群保证高可用

（2）进行数据预热，给不同的key设置随机的过期时间

（3）给缓存业务添加限流降级，通过加锁或队列控制操作redis的线程数量

（4）给业务添加多级缓存

#### 8.Redis分布式锁的实现原理

原理是使用setnx+setex命令来实现，但是会有一系列问题：

（1）任务时常超过缓存时间，锁自动释放。可以使用Redision看门狗解决

（2）加锁和释放锁的不是同一线程。可以在Value中存入uuid，删除时进行验证。但是要注意验证锁和删除锁也不是一个原子性操作，可以用lua脚本使之成为原子性操作

（3）不可重入。可以使用Redision解决（实现机制类似AQS,计数）

（4）redis集群下主节点宕机导致锁丢失。使用红锁解决

#### 9.Redis集群方案

(1)主从模式：个master节点，多个slave节点，master节点宕机slave自动变成主节点

(2)哨兵模式：在主从集群基础上添加哨兵节点或哨兵集群，用于监控master节点健康状态，通过投票机制选择slave成为主节点

(3)分片集群：主从模式和哨兵模式解决了并发读的问题，但没有解决并发写的问题，因此有了分片集群。分片集群有多个master节点并且不同master保存不同的数据，master之间通过ping相互监测健康状态。客户端请求任意一个节点都会转发到正确节点，因为每个master都被映射到0-16384个插槽上，集群的key是根据key的hash值与插槽绑定

#### 10.Redis集群主从同步原理

主从同步第一次是全量同步：slave第一次请求master节点会根据replid判断是否是第一次同步，是的话master会生成RDB发送给slave。

后续为增量同步：在发送RDB期间，会产生一个缓存区间记录发送RDB期间产生的新的命令,slave节点在加载完后，会持续读取缓存区间中的数据

#### 11.Redis缓存一致性解决方案

Redis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序

先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。

先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。

但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。

#### 12.Redis内存淘汰策略

当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的



### 七.计算机网络系列

#### 1.TCP/IP模型![20200904160558176.png](https://img-blog.csdnimg.cn/20200904160558176.png)

####  2.浏览器输入地址后做了什么？

![20200904160558322.png](https://img-blog.csdnimg.cn/20200904160558322.png)

####  3.TCP三次握手

![20200904160558436.png](https://img-blog.csdnimg.cn/20200904160558436.png)

#### 4.为什么TCP不能两次握手

假设是两次握手，若客户端发起的连接请求阻塞在网络中，会造成该报文的重传，这时服务收到连接请求后会立刻进入连接状态，当双方传输完数据结束连接后，第一次阻塞的请求突然又到达了服务端，此时服务端又进入连接状态，而客户端不会响应服务端的连接确认报文

#### 5.TCP四次挥手

![20200904160558691.png](https://img-blog.csdnimg.cn/20200904160558691.png)

#### 6.为什么要进入时间等待状态？

若客户端发送确认释放包后直接关闭，而服务端因为某种原因没有收到客户端的确认释放包，就会一直发送确认请求，而客户端永远不会再响应该请求。

#### 7.TCP 滑动窗口

TCP 流量控制，主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。如果TCP发送方收到接收方的零窗口通知后，会启动持续计时器。计时器超时后向接收方发送零窗口探测报文，如果响应仍为0，就重新计时，不为0就打破死锁

#### 8.TCP拥塞控制

发送方会维护一个拥塞窗口大小的状态变量，大小取决于网络的拥塞程度。发送方的发送窗口大小是取接收方接收窗口和拥塞窗口中较小的一个

拥塞控制有四种算法：

慢开始：从小到大主键发送窗口，每收到一个确认报文窗口大小指数增长

拥塞避免：当窗口大小到达一定阈值时，转为拥塞避免，每收到一个确认报文窗口大小+1。若此时网络超时，就把阈值调小一半，重新慢开始

快重传：要求接收方收到请求后要立即回复

快恢复：发送方连续收到多个确认时，就把拥塞避免阈值减小，然后直接开始拥塞避免

#### 9.TCP超时重传

发送方在发送按数据后一定时间内没有收到接收方响应报文，就会重新发送刚刚的报文，接收到收到报文后会对该报文的序列号进行检验，已存在就抛弃

#### 10.TCP可靠传输的实现

TCP是靠滑动窗口协议和连续ARQ协议配合流量控制和拥塞控制来保证的可靠传输。

ARQ是停止等待协议和自动重传请求，它规定TCP要为每一次传输的包编号，每发送一个包，要等待对方确认后才能发送下一个分组，若一段时间对方没有确认，就重新发送刚刚的报文。接收方会对数据包排序，把有序数据传给应用层，返回缺失的第一个ACK确认序列号给发送方,接收到收到报文后会对该报文的序列号进行检验，重复就丢弃。

流量控制是.....拥塞窗口上......（上面已经说了）

#### 11.TCP报头有哪些信息

![watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjczNjAyNA==,size_16,color_FFFFFF,t_70](https://img-blog.csdnimg.cn/20181129174610446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjczNjAyNA==,size_16,color_FFFFFF,t_70)

####  12.状态码

1xx:请求正在处理

2xx:请求成功处理

3xx:请求重定向  301：永久重定向   302：临时重定向    304：使用本地缓存

4xx:客户端错误  400：请求格式错误  403：没有访问权限  415：请求体过大

5xx:服务端错误



#### 13.http与https的区别





#### 14.socket通信流程

（1）服务端创建socket并调用bind()方法绑定ip和端口号

（2）服务端调用listen()方法建立监听，此时服务的scoket还没有打开

（3）客户端创建socket并调用connect()方法像服务端请求连接

（4）服务端socket监听到客户端请求后，被动打开，调用accept()方法接收客户端连接请求，当accept()方法接收到客户端connect()方法返回的响应成功的信息后，连接成功

（5）客户端向socket写入请求信息，服务端读取信息

（6）客户端调用close()结束链接，服务端监听到释放连接请求后，也结束链接



### 八.linux系列

#### 1.linux常用命令

ifconfig:查看网络接口详情

ping：查看与某主机是否能联通

ps -ef|grep 进程名称：查看进程号

lost -i 端口 ：查看端口占用情况

top:查看系统负载情况，包括系统时间、系统所有进程状态、cpu情况

free:查看内存占用情况

kill:正常杀死进程，发出的信号可能会被阻塞

kill -9:强制杀死进程，发送的是exit命令，不会被阻塞



#### 2.linux的io模型

IO是对磁盘或网络数据的读写，用户进程读取一次IO请求分为两个阶段：等待数据到达内核缓冲区和将内核缓冲区数据拷贝到用户空间，当用户去内核中拷贝数据时，要从用户态转为核心态

5中io模型:

(1)同步阻塞IO模型

用户进程发起io调用后会被阻塞，等待内核缓冲区数据准备完毕时就被唤醒，将内核数据复制到用户进程。这两个阶段都是阻塞的

(2)同步非阻塞IO模型

用户进程发起IO调用后，若内核缓冲区数据还未准备好，进程会继续干别的事，每隔一段时间就去看看内核数据是否准备好。不过将内核数据复制到用户进程这个阶段依旧是阻塞的

(3)IO多路复用模型

linux中把一切都看成文件，每个文件都有一个文件描述符（FD）来关联， IO多路复用模型就是复用单个进程同时监测多个文件描述符，当某个文件描述符可读或可写，就去通知用户进程。

(4)信号IO模型

用户进程发起IO调用后，会向内核注册一个信号处理函数然后继续干别的事，当内核数据准备就绪时就通知用户进程来进行拷贝。

（5）异步非阻塞模型

前面四种全是同步的。进程在发起IO调用后，会直接返回结果。待内核数据准备好时，由内核将数据复制给用户进程。两个阶段都是非阻塞的



#### 4.IO多路复用详解

linux中把一切都看成文件，每个文件都有一个文件描述符（FD）来关联， IO多路复用模型就是复用单个进程同时监测多个文件描述符，当某个文件描述符可读或可写，就去通知用户进程。IO多路复用有三种方式

（1）select：采用数组结构，监测的fd有限，默认为1024；当有文件描述符就绪时，需要遍历整个FD数组来查看是哪个文件描述符就绪了，效率较低；每次调用select时都需要把整个文件描述符数组从用户态拷贝到内核态中来回拷贝，当fd很多时开销会很大；

（2）poll：采用链表结构，监测的文件描述符没有上限，其它的根select差不多

（3）epoll：采用红黑树结构，监测的fd没有上限，它有三个方法，epoll_create() 用于创建一个epoll实例，epoll实例中有一颗红黑树记录监测的fd，一个链表记录就绪的fd;epoll_ctl() 用于往epoll实例中增删要监测的文件描述符，并设置回调函数，当文件描述符就绪时触发回调函数将文件描述符添加到就绪链表当中；epoll_wait() 用于见擦汗就绪列表并返回就绪列表的长度，然后将就绪列表的拷贝到用户空间缓冲区中。

所以epoll的优点是当有文件描述符就绪时，只把已就绪的文件描述符写给用户空间，不需要每次都遍历FD集合；每个FD只有在调新增的时候和就绪的时候才会在用户空间和内核空间之间拷贝一次。

#### 5.epoll的LT和ET模式

LT（默认）：水平触发，当FD有数据可读的时候，那么每次 epoll_wait都会去通知用户来操作直到读完

ET：边缘触发，当FD有数据可读的时候，它只会通知用户一次，直到下次再有数据流入才会再通知，所以在ET模式下一定要把缓冲区的数据一次读完



