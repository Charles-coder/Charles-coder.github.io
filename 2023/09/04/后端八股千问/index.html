<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>后端八股千问 | 荒岛</title><meta name="keywords" content="JAVA，面经"><meta name="author" content="Charles"><meta name="copyright" content="Charles"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="后端八股千问"><meta name="application-name" content="后端八股千问"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="每日20题！！！一千零一个java八股文">
<meta property="og:type" content="article">
<meta property="og:title" content="后端八股千问">
<meta property="og:url" content="http://example.com/2023/09/04/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%8D%83%E9%97%AE/index.html">
<meta property="og:site_name" content="荒岛">
<meta property="og:description" content="每日20题！！！一千零一个java八股文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E7%B2%89.png">
<meta property="article:published_time" content="2023-09-04T02:39:41.000Z">
<meta property="article:modified_time" content="2024-05-04T17:39:57.488Z">
<meta property="article:author" content="Charles">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E7%B2%89.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2023/09/04/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%8D%83%E9%97%AE/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><script>if ('serviceWorker' in navigator) {
  if (navigator.serviceWorker.controller) {
    navigator.serviceWorker.addEventListener('controllerchange', function() {
      location.reload()
    })
  }
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
  })
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  changeMainColorPost: undefined,
  algolia: {"appId":"STZ3Q82RNO","apiKey":"26eaa2270c32470206dcbb984510a5ba","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"键入后按下回车搜索！","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '后端八股千问',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-05 01:39:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/1.css"><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="data:image/jpeg;base64,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"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">荒岛</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-127px;"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-127px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/wechat.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/ali.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/ali.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title">后端八股千问</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-04T02:39:41.000Z" title="发表于 2023-09-04 10:39:41">2023-09-04</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-04T17:39:57.488Z" title="更新于 2024-05-05 01:39:57">2024-05-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="后端八股千问"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为西安"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>西安</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E7%B2%89.png"></div></header><main class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><div id="ai-tag">Tianli GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己</div><div class="ai-btn-item">生成本文简介</div><div class="ai-btn-item">推荐相关文章</div><div class="ai-btn-item">前往主页</div><div class="ai-btn-item" id="go-tianli-blog">前往tianli博客</div></div><script data-pjax>(function(){
  // 当前随机到的ai摘要到index
  let lastAiRandomIndex = -1;
  let animationRunning = true; // 标志变量，控制动画函数的运行
  // 当前gpt模式
  let mode = "tianli"
  // 刷新点击次数
  let refreshNum = 0
  // 记录上一次传递给aiAbstract的参数
  let prevParam;
  const aiTitleRefreshIcon = document.querySelector(".ai-title .anzhiyufont.anzhiyu-icon-arrow-rotate-right")
  const explanation = document.querySelector(".ai-explanation");
  const post_ai = document.querySelector(".post-ai-description");
  let ai_str = "";
  let ai_str_length = "";
  let delay_init = 600;
  let i = 0;
  let j = 0;
  let sto = [];
  let elapsed = 0;
  const animate = timestamp => {
    if (!animationRunning) {
      return; // 动画函数停止运行
    }
    if (!animate.start) animate.start = timestamp;
    elapsed = timestamp - animate.start;
    if (elapsed >= 20) {
      animate.start = timestamp;
      if (i < ai_str_length - 1) {
        let char = ai_str.charAt(i + 1);
        let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;
        if (explanation.firstElementChild) {
          explanation.removeChild(explanation.firstElementChild);
        }
        explanation.innerHTML += char;
        let div = document.createElement("div");
        div.className = "ai-cursor";
        explanation.appendChild(div);
        i++;
        if (delay === 150) {
          document.querySelector(".ai-explanation .ai-cursor").style.opacity = "0";
        }
        if (i === ai_str_length - 1) {
          observer.disconnect(); // 暂停监听
          explanation.removeChild(explanation.firstElementChild);
        }
        sto[0] = setTimeout(() => {
          requestAnimationFrame(animate);
        }, delay);
      }
    } else {
      requestAnimationFrame(animate);
    }
  };
  const observer = new IntersectionObserver(
    entries => {
      let isVisible = entries[0].isIntersecting;
      animationRunning = isVisible; // 标志变量更新
      if (animationRunning) {
        delay_init = i === 0 ? 200 : 20;
        sto[1] = setTimeout(() => {
          if (j) {
            i = 0;
            j = 0;
          }
          if (i === 0) {
            explanation.innerHTML = ai_str.charAt(0);
          }
          requestAnimationFrame(animate);
        }, delay_init);
      }
    },
    { threshold: 0 }
  );
  function clearSTO() {
    if (sto.length) {
      sto.forEach(item => {
        if (item) {
          clearTimeout(item);
        }
      });
    }
  }
  function startAI(str, df = true) {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    observer.disconnect(); // 暂停上一次监听
    explanation.innerHTML = df ? "生成中. . ." : "请等待. . .";
    ai_str = str;
    ai_str_length = ai_str.length;
    observer.observe(post_ai); //启动新监听
  }

  async function aiAbstract(num = 1000) {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    observer.disconnect(); // 暂停上一次监听
    if (mode === "tianli") {
      num = Math.max(10, Math.min(2000, num));
      const options = {
        key: "81af91a2762a1b8a3908",
        Referer: "https://xx.xx/"
      };
      const truncateDescription = ("后端八股千问" + "三、高并发, 一、JAVA基础篇, 1.接口和抽象类的区别, 2.重载和重写的区别, 3.x3Dx3D和equals的区别, 4.异常处理机制, 5.HashMap原理, 6.想要线程安全的HashMap怎么办？, 7.ConcurrentHashMap原如何保证的线程安全？, 8.HashTable与HashMap的区别, 9.ArrayList和LinkedList的区别, 10.如何保证ArrayList的线程安全？, 11.String、StringBuffer、StringBuilder的区别, 12.hashCode和equals, 13.面向对象和面向过程的区别, 4.深拷贝和浅拷贝, 15.多态的作用, 16.什么是反射？, 17.Java创建对象得五种方式?, 二.Java多线程篇, 1.进程和线程的区别进程间如何通信, 2. 什么是线程上下文切换, 3.什么是死锁, 4.死锁的必要条件, 5.Synchrpnized和lock的区别, 6.什么是AQS锁?, 8.有哪些常见的AQS锁, 10.yield()和join()区别, 11.线程池七大参数, 12.Java内存模型, 13.保证并发安全的三大特性？, 14.volatile, 15.线程使用方式, 16.ThreadLocal原理, 17.什么是CAS锁, 18.Synchronized锁原理和优化, 19.如何根据 CPU 核心数设计线程池线程数量, 20.AtomicInteger的使用场景, 三.JVM篇, 1.JVM运行时数据区（内存结构）, 2.什么情况下会内存溢出？, 3.JVM有哪些垃圾回收算法？, 4.GC如何判断对象可以被回收？, 5.典型垃圾回收器, 6.类加载器和双亲委派机制, 7.JVM中有哪些引用？, 8.类加载过程, 9.JVM类初始化顺序, 10..对象的创建过程, 11.对象头中有哪些信息, 12.JVM内存参数, 13.GC的回收机制和原理, 四.Mysql篇, 1.MyIsAm和InnoDB的区别, 2.mysql事务特性, 3.事务靠什么保证, 4.事务的隔离级别, 5.什么是快照读和当前读, 6.MVCC是什么, 7.MySQL有哪些索引, 8.聚簇索引和非聚簇索引的区别, 9.MySQL如何做慢SQL优化, 10.为什么要用内连接而不用外连接？, 11.MySQL整个查询的过程, 12.执行计划中有哪些字段？, 13.哪些情况索引会失效, 14.B和B+数的区别为什么使用B+数, 15.MySQL有哪些锁, 16.Mysql内连接、左连接、右连接的区别, 17.sql执行顺序, 18.如何设计数据库？, 19.where和having的区别？, 20.三大范式, 21.char和varchar的区别, 22.InnoDB 什么情况下会产生死锁, 23.MySQL 删除自增 id随后重启 MySQL 服务再插入数据自增 id 会从几开始？, 24.MySQL插入百万级的数据如何优化？, 五.常用开发框架系列, 1.什么是Spring？, 2.IOC是什么？, 3.AOP是什么？, 4.如何定义一个全局异常处理类？, 5.如何使用aop自定义日志？, 6.循环依赖是什么怎么解决的？, 7.Bean 的作用域, 8.Bean 生命周期, 9.Spring 事务原理？, 10.spring事务失效场景, 11.spring事务的隔离级别, 12.spring事务的传播行为, 13.Spring IoC, 12.spring用了哪些设计模式, 14.SpringMV工作原理, 15.springboot自动配置原理, 16 .springboot常用注解, 17.spring的bean是线程安全的吗？, 18.springcloud主要解决什么问题？, 19.CAP理论, 20.为什么不能同时保证一致性和可用性呢？, 21.熔断限流的理解？, 22.常用限流算法, , 六.Redis系列, 1.redis为什么快？, 2.redis持久化机制, 3.Redis如何实现key的过期删除？, 4.Redis数据类型应用场景, 5.Redis缓存穿透如何解决？, 6.Redis如何解决缓存击穿？, 7.Redis如何解决缓存雪崩？, 8.Redis分布式锁的实现原理, 9.Redis集群方案, 10.Redis集群主从同步原理, 11.Redis缓存一致性解决方案, 12.Redis内存淘汰策略, 七.计算机网络系列, 1.TCPx2FIP模型, 2.浏览器输入地址后做了什么？, 3.TCP三次握手, 4.为什么TCP不能两次握手, 5.TCP四次挥手, 6.为什么要进入时间等待状态？, 7.TCP 滑动窗口, 8.TCP拥塞控制, 9.TCP超时重传, 10.TCP可靠传输的实现, 11.TCP报头有哪些信息, 12.状态码, 13.http与https的区别, 14.socket通信流程, 八.linux系列, 1.linux常用命令, 2.linux的io模型, 4.IO多路复用详解, 5.epoll的LT和ET模式什么是语言有哪些特点和有什么区别说说什么是跨平台性原理是什么什么是字节码采用字节码的好处是什么为什么说语言编译与解释并存有哪些数据类型自动类型转换强制类型转换看看这几行代码什么是自动拆箱封箱和有什么区别是否能作用在上的区别及作用用最有效率的方法计算乘以说说自增自减运算看下这几个代码运行结果向对象和向过程的区别面向对象有哪些特性重载和重写的区别访问修饰符以及不写默认时的区别关键字有什么作用抽象类和接口有什么区别三高并发并行与并发的区别什么是进程和线程进程系统进行资源分配调度的基本单位线程是进程的一个执行路径一个进程至少有一个线程同一一进程多个线程共享进程的资源操作系统分配资源是给进程的资源是给现成的比如启动函数就是启动了一个进程函数就是一个主线程说说线程有几种创建方式继承类重写方法调用实现接口重写方法实现接口重写方法为什么调用方法时会执行方法那怎么不直接调用方法执行方法会先创建一条线程由创建出来的新线程去执行的方法这才起到多线程的效果为什么我们不能直接调用方法也很清楚如果直接调用的方法那么方法还是运行在主线程中相当于顺序执行就起不到多线程的效果线程有哪些常用的调度方法类也提供了一个方法用于等待的方法如果一个线程执行了语句其含义是当前线程等待线程终止之后才从返回线程会暂时让出指定时间的执行权但是线程所拥有的监视器资源比如锁还是持有不让出的指定的睡眠时间到了后该函数会正常返回接着参与的调度获取到资源后就可以继续运行线程有几种状态什么是线程上下文切换使用多线程的目的是为了充分利用但是我们知道并发其实是一个来应付多个线程为了让用户感觉多个线程是在同时执行的资源的分配采用了时间片轮转也就是给每个线程分配一个时间片线程在时间片内占用执行任务当线程使用完时间片后就会处于就绪状态并让出让其他线程占用这就是上下文切换守护线程了解吗中的线程分为两类分别为线程守护线程和线程用户线程在启动时会调用函数函数所在的钱程就是一个用户线程其实在内部同时还启动了很多守护线程比如垃圾回收线程那么守护线程和用户线程有什么区别呢区别之一是当最后一个非守护线程束时会正常退出而不管当前是否存在守护线程也就是说守护线程是否结束并不影响退出换而言之只要有一个用户线程还没结束正常情况下就不会退出线程间有哪些通信方式和关键字关键字可以用来修饰字段成员变量就是告知程序任何对该变量的访问均需要从共享内存中获取而对它的改变必须同步刷新回共享内存它能保证所有线程对变量访问的可见性关键字可以修饰方法或者以同步块的形式来进行使用它主要确保多个线程在同一个时刻只能有一个线程处于方法或者同步块中它保证了线程对变量访问的可见性和排他性等待通知机制可以通过内置的等待通知机制实现一个线程修改一个对象的值而另一个线程感知到了变化然后进行相应的操作管道输入输出流管道输入输出流和普通的文件输入输出流或者网络输入输出流不同之处在于它主要用于线程之间的数据传输而传输的媒介为内存使用如果一个线程执行了语句其含义是当前线程等待线程终止之后才从返回线程除了提供方法之外还提供了和两个具备超时特性的方法使用即线程变量是一个以对象为键任意对象为值的存储结构这个结构被附带在线程上也就是说一个线程可以根据一个对象查询到绑定在这个线程上的一个值可以通过方法来设置一个值在当前线程下再通过方法获取到原先设置的值是什么也就是线程本地变量如果你创建了一个变量那么访问这个变量的每个线程都会有这个变量的一个本地拷贝多个线程操作这个变量的时候实际是操作自己本地内存里面的变量从而起到线程隔离的作用避免了线程安全问题一基础篇接口和抽象类的区别相似点接口和抽象类都不能被实例化实现接口或继承抽象类的普通子类都必须实现这些抽象方法不同点抽象类可以包含普通方法和代码块接口里只能包含抽象方法静态方法和默认方法抽象类可以有构造方法而接口没有抽象类中的成员变量可以是各种类型的接口的成员变量只能是类型的并且必须赋值重载和重写的区别重载发生在同一个类中方法名相同参数列表返回类型权限修饰符可以不同重写发生在子类中方法名相参数列表返回类型都相同权限修饰符要大于父类方法声明异常范围要小于父类方法但是和修饰的方法不可重写和的区别比较基本类型比较的是值比较引用类型比较的是内存地址是类的方法本质上与一样但是有些类重写了方法比如的被重写后比较的是字符值另外重写了后也必须重写方法异常处理机制使用捕获异常中的代码一定会执行捕获异常后程序会继续执行使用声明该方法可能会抛出的异常类型出现异常后程序终止原理在以后是基于数组链表红黑树来实现的特点是不能重复可以为线程不安全的扩容机制的默认容量为默认的负载因子为当中元素个数超过容量乘以负载因子的个数时就创建一个大小为前一次两倍的新数组再将原来数组中的数据复制到新数组中当数组长度到达且链表长度大于时链表转为红黑树存取原理计算的值然后进行二次根据二次结果找到对应的索引位置如果这个位置有值先进性比较若结果为则取代该元素若结果为就使用高低位平移法将节点插入链表以前使用头插法但是头插法在并发扩容时可能会造成环形链表或数据丢失而高低位平移发会发生数据覆盖的情况想要线程安全的怎么办使用使用方法原如何保证的线程安全使用分段锁将一个分为了个段每个段都是一个小的每次操作只对其中一个段加锁采用保证线程安全每次插入数据时判断在当前数组下标是否是第一次插入是就通过方式插入然后判断是否是的话就说明其他线程正在进行扩容当前线程也会参与扩容删除方法用了修饰保证并发下移除元素安全与的区别的每个方法都用修饰因此是线程安全的但同时读写效率很低的不允许为只对进行一次进行了两次底层使用的数组加链表和的区别的底层使用动态数组默认容量为当元素数量到达容量时生成一个新的数组大小为前一次的倍然后将原来的数组过来因为数组在内存中是连续的地址所以查找数据更快由于扩容机制添加数据效率更低的底层使用链表在内存中是离散的没有扩容机制在查找数据时需要从头遍历所以查找慢但是添加数据效率更高如何保证的线程安全使用方法为加锁使用底层与相同但是每个方法都由修饰速度很慢使用下的该类实现了读操作不加锁写操作时为创建一个副本期间其它线程读取的都是原本写操作都在副本中进行写入完成后再将指针指向副本的区别由数组构成使用了修饰对进行改变时每次都会新生成一个对象然后把指针指向新的引用对象可变并且线程安全可变但线程不安全操作少量字符数据用单线程操作大量数据用多线程操作大量数据用和和都是类的方法默认是通过地址来计算码但是可能被重写过用内容来计算码默认通过地址判断两个对象是否相等但是可能被重写用内容来比较两个对象所以两个对象相等他们的和一定相等但是相等的两个对象未必相等如果重写必须重写比如在中如果是类型如果只重写了而没有重写的话则两个比较为的因为不同导致两个没有出现在一个索引上就会出现中存在两个相同的面向对象和面向过程的区别面向对象有封装继承多态性的特性所以相比面向过程易维护易复用易扩展但是因为类调用时要实例化所以开销大性能比面向过程低深拷贝和浅拷贝浅拷贝浅拷贝只复制某个对象的引用而不复制对象本身新旧对象还是共享同一块内存深拷贝深拷贝会创造一个一摸一样的对象新对象和原对象不共享内存修改新对象不会改变原对对象多态的作用多态的实现要有继承重写父类引用指向子类对象它的好处是可以消除类型之间的耦合关系增加类的可扩充性和灵活性什么是反射反射是通过获取类的对象然后动态的获取到这个类的内部结构动态的去操作类的属性和方法应用场景有要操作权限不够的类属性和方法时实现自定义注解时动态加载第三方包时按需加载类节省编译和初始化时间获取对象的方法有类路径类对象的创建对象得五种方式关键字方法反序列化二多线程篇进程和线程的区别进程间如何通信进程系统运行的基本单位进程在运行过程中都是相互独立但是线程之间运行可以相互影响线程独立运行的最小单位一个进程包含多个线程且它们共享同一进程内的系统资源进程间通过管道共享内存信号量机制消息队列通信什么是线程上下文切换当一个线程被剥夺使用权时切换到另外一个线程执行什么是死锁死锁指多个线程在执行过程中因争夺资源造成的一种相互等待的僵局死锁的必要条件互斥条件同一资源同时只能由一个线程读取不可抢占条件不能强行剥夺线程占有的资源请求和保持条件请求其他资源的同时对自己手中的资源保持不放循环等待条件在相互等待资源的过程中形成一个闭环想要预防死锁只需要破坏其中一个条件即可比如使用定时锁尽量让线程用相同的加锁顺序还可以用银行家算法可以预防死锁和的区别是关键字是一个类在发生异常时会自动释放锁需要手动释放锁是可重入锁非公平锁不可中断锁的是可重入锁可中断锁可以是公平锁也可以是非公平锁是层次通过监视器实现的是通过实现的什么是锁是一个抽象类可以用来构造锁和同步类如的原理是内部有三个核心组件一个是代表加锁状态初始值为一个是获取到锁的线程还有一个阻塞队列当有线程想获取锁时会以的形式将变为成功后便将加锁线程设为自己当其他线程来竞争锁时会判断是不是不是再判断加锁线程是不是自己不是的话就把自己放入阻塞队列这个阻塞队列是用双向链表实现的可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己是的话释放锁的时候就将当减到的时候就去唤醒阻塞队列的第一个线程为什么使用的双向链表因为有一些线程可能发生中断而发生中断时候就需要在同步阻塞队列中删除掉这个时候用双向链表方便删除掉中间的节点有哪些常见的锁分为独占锁和共享锁独占锁可重入可中断可以是公平锁也可以是非公平锁非公平锁就是会通过两次去抢占锁公平锁会按队列顺序排队信号量设定一个信号量当调用时判断是否还有信号有就获取一个信号量没有就阻塞等待其他线程释放信号量当调用时释放一个信号量唤醒阻塞线程应用场景允许多个线程访问某个临界资源时如上下车买卖票倒计数器给计数器设置一个初始值当调用时计数器减一当调用时判断计数器是否归不为就阻塞直到计数器为应用场景启动一个服务时主线程需要等待多个组件加载完毕之后再继续执行循环栅栏给计数器设置一个目标值当调用时会计数并判断计数器是否达到目标值未达到就阻塞直到计数器达到目标值应用场景多线程计算数据最后合并计算结果的应用场景和的区别是的方法是类的方法会释放锁不会释放锁要在同步方法或者同步代码块中执行没有限制要调用或唤醒自动唤醒和区别调用后线程进入就绪状态线程中调用线程的则执行完前进入阻塞状态线程池七大参数核心线程数线程池中的基本线程数量最大线程数当阻塞队列满了之后逐一启动最大线程的存活时间当阻塞队列的任务执行完后最大线长的回收时间最大线程的存活时间单位阻塞队列当核心线程满后后面来的任务都进入阻塞队列线程工厂用于生产线程任务拒绝策略阻塞队列满后拒绝任务有四种策略抛异常丢弃任务不抛异常打回任务尝试与最老的线程竞争内存模型内存模型屏蔽了各种硬件和操作系统的内存访问差异实现让程序在各平台下都能达到一致的内存访问效果它定义了如何将程序中的变量在主存中读取具体定义为所有变量都存在主存中主存是线程共享区域每个线程都有自己独有的工作内存线程想要操作变量必须从主从中变量到自己的工作区每个线程的工作内存是相互隔离的由于主存与工作内存之间有读写延迟且读写不是原子性操作所以会有线程安全问题保证并发安全的三大特性原子性一次或多次操作在执行期间不被其他线程影响可见性当一个线程在工作内存修改了变量其他线程能立刻知道有序性对指令的优化会让指令执行顺序改变有序性是禁止指令重排保证变量的可见性和有序性不保证原子性使用了修饰变量后在变量修改后会立即同步到主存中每次用这个变量前会从主存刷新单例模式双重校验锁变量为什么使用修饰禁止指令重排序分为三个步骤为实例对象分配内存用构造器初始化成员变量将实例对象引用指向分配的内存实例对象在分配内存后实才不为如果分配内存后还未初始化就先将实例对象指向了内存那么此时最外层的会判断实例对象已经不等于就直接将实例对象返回而此时初始化还没有完成线程使用方式继承类实现接口实现接口带有返回值线程池创建线程原理原理是为每个线程创建变量副本不同线程之间不可见保证线程安全每个线程内部都维护了一个为实例为要保存的副本但是使用会存在内存泄露问题因为为弱引用而为强引用每次时都会回收而不会被回收所以为了解决内存泄漏问题可以在每次使用完后删除或者使用修饰可以随时获取什么是锁锁可以保证原子性思想是更新内存时会判断内存值是否被别人修改过如果没有就直接更新如果被修改就重新获取值直到更新完成为止这样的缺点是只能支持一个变量的原子操作不能保证整个代码块的原子操作频繁失败导致开销大问题线程和线程同时去修改一个变量将值从改为但线程突然阻塞此时线程将改为然后线程又将改成此时线程将又改为这个过程线程是不知道的这就是问题可以通过版本号或时间戳解决锁原理和优化是通过对象头的来表明监视器的监视器本质是依赖操作系统的互斥锁实现的操作系统实现线程切换要从用户态切换为核心态成本很高此时这种锁叫重量级锁在以后引入了偏向锁轻量级锁重量级锁偏向锁当一段代码没有别的线程访问此时线程去访问会直接获取偏向锁轻量级锁当锁是偏向锁时有另外一个线程来访问会升级为轻量级锁线程会通过方式获取锁不会阻塞提高性能重量级锁轻量级锁自旋一段时间后线程还没有获取到锁会升级为重量级锁重量级锁时来竞争锁的所有线程都会阻塞性能降低注意锁只能升级不能降级如何根据核心数设计线程池线程数量密集型线程中十分消耗的线程数密集型线程数量的使用场景是一个提供原子操作的类使用实来现线程安全的数值操作因为禁止了的排序优化所以它不适合在并发量小的时候使用只适合在一些高并发程序中使用三篇运行时数据区内存结构线程私有区虚拟机栈每次调用方法都会在虚拟机栈中产生一个栈帧每个栈帧中都有方法的参数局部变量方法出口等信息方法执行完毕后释放栈帧本地方法栈为修饰的本地方法提供的空间在中与虚拟机合二为一程序计数器保存指令执行的地址方便线程切回后能继续执行代码线程共享区堆内存进行垃圾回收的主要区域存放对象信息分为新生代和老年代内存比例为新生代的区内存不够时时发生老年代内存不够时发生方法区存放类信息静态变量常量运行时常量池等信息之前用持久代实现后用元空间实现元空间使用的是本地内存而非在内存结构中什么情况下会内存溢出堆内存溢出当对象一直创建而不被回收时加载的类越来越多时虚拟机栈的线程越来越多时栈溢出方法调用次数过多一般是递归不当造成有哪些垃圾回收算法标记清除算法标记不需要回收的对象然后清除没有标记的对象会造成许多内存碎片复制算法将内存分为两块只使用一块进行垃圾回收时先将存活的对象复制到另一块区域然后清空之前的区域用在新生代标记整理算法与标记清除算法类似但是在标记之后将存活对象向一端移动然后清除边界外的垃圾对象用在老年代如何判断对象可以被回收引用计数法已淘汰为每个对象添加引用计数器引用为时判定可以回收会有两个对象相互引用无法回收的问题可达性分析法从开始往下搜索搜索过的路径称为引用链若一个对象没有任何的引用链则判定可以回收有虚拟机栈中引用的对象方法区中静态变量引用的对象本地方法栈中引用的对象典型垃圾回收器以最小的停顿时间为目标只运行在老年代的垃圾回收器使用标记清除算法可以并发收集以后的默认垃圾回收器注重响应速度支持并发采用标记整理复制算法回收内存使用可达性分析法来判断对象是否可以被回收类加载器和双亲委派机制从父类加载器到子类加载器分别为加载路径为加载路径为加载路径为还有一个自定义类加载器当一个类加载器收到类加载请求时会先把这个请求交给父类加载器处理若父类加载器找不到该类再由自己去寻找该机制可以避免类被重复加载还可以避免系统级别的类被篡改中有哪些引用强引用的对象哪怕内存溢出也不会回收软引用只有内存不足时才会回收弱引用每次垃圾回收都会回收虚引用必须配合引用队列使用一般用于追踪垃圾回收动作类加载过程加载把字节码通过二进制的方式转化到方法区中的运行数据区连接验证验证字节码文件的正确性准备正式为类变量在方法区中分配内存并设置初始值类型的变量在编译时已经赋值了解析将常量池中的符号引用如类的全限定名解析为直接引用类在实际内存中的地址初始化执行类构造器不是常规的构造方法为静态变量赋初值并初始化静态代码块类初始化顺序父类静态代码块和静态成员变量子类静态代码块和静态成员变量父类代码块和普通成员变量父类构造方法子类代码块和普成员变量子类构造方法对象的创建过程检查类是否已被加载没有加载就先加载类为对象在堆中分配内存使用方式分配防止在为分配内存时执行当前地址的指针还没有来得及修改对象就拿来分配内存初始化将对象中的属性都分配值或设置对象头为属性赋值和执行构造方法对象头中有哪些信息对象头中有两部分一部分是存储对象运行时的数据如对象的分代年龄标记锁的状态获取到锁的线程等另外一部分是表明对象所属类如果是数组还有一个部分存放数组长度内存参数堆空间最大内存堆空间最小内存一般设置成跟堆空间最大内存一样的新生代的最大内存区与区的比例为默认为垃圾回收器名称指定垃圾回收器设置单个线程栈大小一般设堆空间为最大可用物理地址的百分之的回收机制和原理的目的实现内存的自动释放使用可达性分析法判断对象是否可回收采用了分代回收思想将堆分为新生代老年代新生代中采用复制算法老年代采用整理算法当新生代内存不足时会发生老年代不足时会发送四篇和的区别有三大特性分别是事务外键行级锁这些都是不支持的另外是聚簇索引是非聚簇索引不支持全文索引支持支持自增和模式的读写不支持的访问速度一般快差异在于的行锁会比较消耗性能还可能有回表的过程先去辅助索引中查询数据找到数据对应的之后再通过回表到聚簇索引树查找数据事务特性原子性一个事务内的操作统一成功或失败一致性事务前后的数据总量不变隔离性事务与事务之间相互不影响持久性事务一旦提交发生的改变不可逆事务靠什么保证原子性由日志保证他记录了需要回滚的日志信息回滚时撤销已执行的一致性由其他三大特性共同保证是事务的目的隔离性由保证持久性由日志和内存保证修改数据时内存和会记录操作宕机时可恢复事务的隔离级别在高并发情况下并发事务会产生脏读不可重复读幻读问题这时需要用隔离级别来控制读未提交允许一个事务读取另一个事务已提交的数据可能出现不可重复读幻读读提交只允许事务读取另一个事务没有提交的数据可能出现不可重复读幻读可重复读确保同一字段多次读取结果一致可能出现欢幻读可串行化所有事务逐次执行没有并发问日默认隔离级别为可重复读级别分为快照度和当前读并且通过间隙锁解决了幻读问题什么是快照读和当前读快照读读取的是当前数据的可见版本可能是会过期数据不加锁的就是快照都当前读读取的是数据的最新版本并且当前读返回的记录都会上锁保证其他事务不会并发修改这条记录如排他锁共享锁都是当前读是什么是多版本并发控制为每次事务生成一个新版本数据每个事务都由自己的版本从而不加锁就决绝读写冲突这种读叫做快照读只在读已提交和可重复读中生效实现原理由四个东西保证他们是日志记录了数据历史版本事务进行快照读时动态生成产生的视图记录了当前系统中活跃的事务控制哪个历史版本对当前事务可见隐藏字段最近修改记录的事务隐藏字段回滚指针配合指向数据的上一个版本有哪些索引主键索引一张表只能有一个主键索引主键索引列不能有空值和重复值唯一索引唯一索引不能有相同值但允许为空普通索引允许出现重复值组合索引对多个字段建立一个联合索引减少索引开销遵循最左匹配原则全文索引引擎支持通过建立倒排索引提升检索效率广泛用于搜索引擎聚簇索引和非聚簇索引的区别聚簇索引聚簇索引的叶子节点存放的是主键值和数据行辅助索引在聚簇索引上创建的其它索引的叶子节点存放的是主键值或指向数据行的指针优点根据索引可以直接获取值所以他获取数据更快对于主键的排序查找和范围查找效率更高缺点如果主键值很大的话辅助索引也会变得很大如果用作为主键数据存储会很稀疏修改主键或乱序插入会让数据行移动导致页分裂所以一般我们定义主键时尽量让主键值小并且定义为自增和不可修改非聚簇索引辅助索引叶子节点存放的是数据行地址先根据索引找到数据地址再根据地址去找数据他们都是数结构如何做慢优化可以查看执行计划分析数据的扫描类型索引是否生效常见的慢查询优化有尽量减少的数据列尽量使用覆盖索引查找时使用索引进行排序否则的话需要进行回表查询时同样要用索引避免使用到临时表分页查询时如果后面的数字太大可以使用子查询查出主键再主键后条数据就能走覆盖索引使用复杂查询时使用关联查询来代替子查询并且最好使用内连接使用函数时直接使用的话的效率最高或唯一索引或数字表中总记录数字段不会统计在写语句时条件要使用索引否则会锁会从行锁升级为表锁表中数据是否太大是不是要分库分表为什么要用内连接而不用外连接用外连接的话连接顺序是固定死的比如他必须先对左表进行全表扫描然后一条条到右表去匹配而内连接的话会自己根据查询优化器去判断用哪个表做驱动子查询的话同样也会对驱动表进行全表扫描所以尽量用小表做驱动表整个查询的过程客户端向服务器发送一条查询请求服务器首先检查查询缓存如果命中缓存则返回存储在缓存中的结果否则进入下一阶段服务器进行解析预处理再由优化器生成对应的执行计划根据执行计划调用存储引擎的来执行查询将结果返回给客户端同时缓存查询结果注意只有在之前才有查询缓存之后查询缓存被去掉了执行计划中有哪些字段我们想看一个的执行计划使用的语句是表中的字段包括扫描类型效率从底到高为全表扫描全索引扫描我们的需要的数据在索引中可以获取使用索引进行范围查找使用非唯一索引列进行了关联查询使用唯一索引进行关联查询使用唯一索引查询一行数据表中只有一行数据额外的如何查询额外信息常见的有在排序缓冲区中进行排序需要回表查询数据表示使用覆盖索引排序时使用了索引排序但如果是按照降序排序的话就会使用反向扫描索引查询时要建立一个临时表存放数据找到了多少行数据实际使用到的索引查询的优先级越大优先级越高子查询的一般会更大查询的类型是普通查询还是联合查询还是子查询常见类型有不包含子查询标记复杂查询中最外层的查询标记只后子查询者一行的数据是数哪张表的可能的当前查询语句可能用到的索引可能为如果用了索引但是为有可能是表数据太少认为全表扫描更快编号显示索引的哪一行被使用了哪些情况索引会失效条件中有除非所有查询条件都有索引否则失效查询用开头索引失效索引列参与计算索引失效违背最左匹配原则索引失效索引字段发生类型转换索引失效觉得全表扫描更快时数据少索引失效和数的区别为什么使用数二叉树索引字段有序极端情况会变成链表形式数树的高度不可控数控制了树的高度但是索引值和都分布在每个具体的节点当中若要进行范围查询要进行多次回溯开销大树非叶子节点只存储索引值叶子节点再存储索引具体数据从小到大用链表连接在一起范围查询可直接遍历不需要回溯有哪些锁基于粒度表级锁对整张表加锁粒度大并发小行级锁对行加锁粒度小并发大间隙锁间隙锁锁住表的一个区间间隙锁之间不会冲突只在可重复读下才生效解决了幻读基于属性共享锁又称读锁一个事务为表加了读锁其它事务只能加读锁不能加写锁排他锁又称写锁一个事务加写锁之后其他事务不能再加任何锁避免脏读问题内连接左连接右连接的区别内连接取量表交集部分左连接取左表全部右表匹部分右连接取右表全部坐表匹部分执行顺序如何设计数据库抽取实体如用户信息商品信息评论分析其中属性如用户信息姓名性别分析表与表之间的关联关系然后可以参考三大范式进行设计设计主键时主键要尽量小并且定义为自增和不可修改和的区别是约束声明是过滤声明早于执行并且不可以使用聚合函数可以三大范式第一范式每个列都不可以再拆分第二范式在第一范式的基础上非主键列完全依赖于主键而不能是依赖于主键的一部分第三范式在第二范式的基础上非主键列只依赖于主键不依赖于其他非主键和的区别是不可变的最大长度为是可变的字符串最大长度为什么情况下会产生死锁事务已经获取数据的写锁想要去获取数据的写锁然后事务获取了的写锁想要去获取的写锁相互等待形成死锁解决死锁的机制有两个等待直到超时发起死锁检测主动回滚一条事务死锁检测的原理是构建一个以事务为顶点锁为边的有向图判断有向图是否存在环存在即有死锁我们平时尽量减少事务操作的资源和隔离级别删除自增随后重启服务再插入数据自增会从几开始引擎前下次自增会取表中最大原理是最大会记录在内存中重启之后会重新读取表中最大的后仍从删除数据后算起原理是它将最大记录在里了自增的都从删除数据后算起原理是它将最大记录到数据文件里了插入百万级的数据如何优化一次插入多条数据可以减少写日志和日志的次数是有长度限制的但可以调整保证数据按照索引进行有序插入可以分表后多线程插入五常用开发框架系列什么是是个轻量级的框架通过达到松耦合的目的通过可以分离应用业务逻辑和系统服务进行内聚性的开发不过配置各种组件时比较繁琐所以后面才出选了的框架是什么是控制反转是一种思想把对象的创建和调用从程序员手中交由容器管理降低对象之间的依赖关系创建一个的方式有方式注解方式方式我们在对一个进行实例化后要对他的属性进行填充大多数我们都是使用直接的填充依赖注入的他是有限按照类型进行匹配是什么是面向切面编程可以将那些与业务不相关但是很多业务都要调用的代码抽取出来思想就是不侵入原有代码的情况下对功能进行增强是基于动态代理实现的动态代理是有两种一种是动态代理一种是动态代理动态代理是原理是利用反射来实现的需要调用反射包下的类的方法来返回代理对象这个方法中有三个参数分别是用于加载代理类的类加载器被代理类实现的接口的数组和一个用于增强方法的实现类动态代理原理是利用开源包来实现的是把被代理类的文件加载进来通过修改它的字节码生成子类来处理动态代理要求被代理类必须有实现的接口生成的动态代理类会和代理类实现同样的接口则生成的动态代理类会继承被代理类默认使用动态代理当被代理的类没有接口时就使用动态代理如何定义一个全局异常处理类想要定义一个全局异常处理类的话我们需要在这个类上添加注解然后定义一些用于捕捉不同异常类型的方法在这些方法上添加异常类型和注解方法参数是和异常类型然后将异常消息进行处理如果我们需要自定义异常的话就写一个自定义异常类该类需要继承一个异常接口类属性包括类型的连续错误码错误信息再根据需求写构造方法如何使用自定义日志第一步创建一个切面类把它添加到容器中并添加注解第二步在切面类中写一个通知方法在方法上添加通知注解并通过切入点表达式来表示要对哪些方法进行日志打印然后方法参数为第三步通过这个参数可以获取当前执行的方法名方法参数等信息这样就可以根据需求在方法进入或结束时打印日志循环依赖是什么怎么解决的循环依赖就是在创建实例的时候里面包含着属性实例所以这个时候就需要去创建实例而创建实例过程中也包含着实例这样实例还在创建的过程当中所以就导致和实例都创建不出来通过三级缓存来解决循环依赖一级缓存单例池缓存经过了已经初始化完毕的二级缓存半成品池缓存还未初始化完毕的三级缓存缓存的是获取的代理对象的表达式我们在创建的过程中先将放入三级缓存这时要创建要创建就直接去三级缓存中查找并且判断需不需要进行处理如果需要就在三级缓存中获取的代理对象不需要就取原始对象然后将取出的对象放入二级缓存中这个时候其他需要依赖对象的直接从二级缓存中去获取即可当初始化完成进入一级缓存后继续执行生命周期当完成了属性的注入后就可以放入一级缓存了之前默认会解决循环依赖在之后需要通过配置开启解决循环依赖的作用域一个容器只有一个每次调用都会生成一个新的对象每个请求都会创建一个自己的同一个共享一个实例整个只有一个一个只有一个生命周期实例化属性赋值初始化销毁在这四步的基础上面提供了一些拓展点自身的方法包括了本身调用的方法和通过配置文件中的和指定的方法级生命周期接口方法包括了和这些接口的方法容器级生命周期接口方法包括了和这两个接口实现一般称它们的实现类为后处理器工厂后处理器接口方法包括了等等非常有用的工厂后处理器接口的方法工厂后处理器也是容器级的在应用上下文装配配置文件之后立即调用事务原理事务有编程式和声明式我们一般使用声明式在某个方法上增加注解这个方法中的会统一成功或失败原理是当一个方法加上注解会基于这个类生成一个代理对象并将这个代理对象作为当使用这个中的方法时如果存在注解就会将事务自动提交设为然后执行方法执行过程没有异常则提交有异常则回滚事务失效场景事务方法所在的类没有加载到容器中事务方法不是类型同一类中一个没有添加事务的方法调用另外以一个添加事务的方法事务不生效事务默认只回滚运行时异常可以用属性设置业务自己捕获了异常事务会认为程序正常秩序事务的隔离级别默认级别使用数据库自定义的隔离级别其它四种隔离级别与一样事务的传播行为支持当前事务如果不存在则新启一个事务支持当前事务如果不存在则抛出异常支持当前事务如果不存在则以非事务方式执行不支持当前事务创建一个新事物不支持当前事务如果已存在事务就抛异常不支持当前事务始终以非事务方式执行用了哪些设计模式用了工厂模式用了动态代理模式用来模板方法模式中用来适配器模式里的监听器用了观察者模式工作原理工作过程围绕着前端控制器几个重要组件有处理器映射器处理器适配器试图解析器工作流程接收用户请求将请求发送给根据请求找到具体的和拦截器返回给调用执行具体的并将返回的返回给将传给解析后返回具体根据进行视图渲染返回给用户自动配置原理在包下存放了内置的自动配置类和文件这个文件中存放了这些配置类的全类名启动类注解下有三个关键注解表示启动类是一个自动配置类扫描启动类所在包下及子包的组件到容器中下面有个子注解会导入上面所说的自动配置类这些配置类会根据元注解的装配条件生效生效的类就会被实例化加载到容器中这些自动配置类还会通过文件里配置来进行属性设值常用注解修饰类该控制器会返回数据修饰类该控制器的请求路径修饰属性按照类型进行依赖注入修饰参数将路径值映射到参数上修饰方法该方法会返回数据需要使用提交方式修饰参数将数据封装到对应参数中将类注册到容器开启事务的是线程安全的吗的默认作用域是单例的单例的不是线程安全的但是开发中大部分的都是无状态的不具备存储功能比如他们不需要保证线程安全如果要保证线程安全可以将的作用域改为比如像另外还可以采用来解决线程安全问题为每个线程保存一个副本变量每个线程只操作自己的副本变量主要解决什么问题解决服务之间的通信容灾负载平衡冗余问题能方便服务集中管理常用组件有注册中心配置中心远程调用服务熔断网关理论一致性这里指的强一致性也就是数据更新完访问任何节点看到的数据完全一致可用性就是任何没有发生故障的服务必须在规定时间内返回合正确结果容灾性当网络不稳定时节点之间无法通信造成分区这时要保证系统可以继续正常服务提高容灾性的办法就是把数据分配到每一个节点当中所以是分布式系统必须实现的然后需要在和中取舍为什么不能同时保证一致性和可用性呢当网络发生故障时如果要保障数据一致性那么节点相互间就只能阻塞等待数据真正同步时再返回就违背可用性了如果要保证可用性节点要在有限时间内将结果返回无法等待其它节点的更新消息此时返回的数据可能就不是最新数据就违背了一致性了熔断限流的理解中用组件来进行降级熔断限流熔断是对于消费者来讲当对提供者请求时间过久时为了不影响性能就对链接进行熔断限流是对于提供者来讲为了防止某个消费者流量太大导致其它更重要的消费者请求无法及时处理限流可用通过拒绝服务服务降级消息队列延时处理限流算法来实现常用限流算法计数器算法使用的和过期机制实现漏桶算法一般使用消息队列来实现系统以恒定速度处理队列中的请求当队列满的时候开始拒绝请求令牌桶算法计数器算法和漏桶算法都无法解决突然的大并发令牌桶算法是预先往桶中放入一定数量然后用恒定速度放入直到桶满为止所有请求都必须拿到才能访问系统六系列为什么快完全基于内存操作数据结构简单对数据操作简单执行命令是单线程的避免了上下文切换带来的性能问题也不用考虑锁的问题采用了非阻塞的多路复用机制使用了单线程来处理并发的连接内部采用的自己实现的事件分离器其实不是完全多线程的在核心的网络模型中是多线程的用来处理并发连接但是数据的操作都是单线程坚持单线程是因为是的性能瓶颈是网络延迟而不是多线程对数据读取不会带来性能提升持久化机制快照持久化的默认持久化机制通过父进程一个子进程子进程将的数据快照写入一个临时文件等待持久化完毕后替换上一次的文件整个过程主进程不进行任何的操作持久化策略可以通过配置单位时间内执行多少次操作触发持久化所以的优点是保证性能最大化恢复速度数据较快缺点是可能会丢失两次持久化之间的数据追加持久化以日志形式记录每一次的写入和删除操作策略有每秒同步每次操作同步不同步优点是数据完整性高缺点是运行效率低恢复时间长如何实现的过期删除采用的定期过期惰性过期定期删除每隔一段时间从设置过期时间的集合中随机抽取一些检查是否过期如果已经过期做删除处理惰性删除在被访问的时候检查是否过期如果过期则删除数据类型应用场景可以用来缓存信息可以用命令实现自增或自减的计数器与一样可以保存信息可以用来做消息队列的是原子性操作能一定程度保证线程安全可以做去重比如一个用户只能参加一次活动可以做交集求共友有序的可以实现排行榜缓存穿透如何解决缓存穿透是指频繁请求客户端和缓存中都不存在的数据缓存永远不生效请求都到达了数据库解决方案在接口上做基础校验比如就拦截缓存空对象找不到的数据也缓存起来并设置过期时间可能会造成短期不一致布隆过滤器在客户端和缓存之间添加一个过滤器拦截掉一定不存在的数据请求如何解决缓存击穿缓存击穿是值一个非常热点在某一瞬间失效导致大量请求到达数据库解决方案设置热点数据永不过期给缓存重建的业务加上互斥锁缺点是性能低如何解决缓存雪崩缓存雪崩是值某一时间同时失效或宕机导致大量请求到达数据库解决方案搭建集群保证高可用进行数据预热给不同的设置随机的过期时间给缓存业务添加限流降级通过加锁或队列控制操作的线程数量给业务添加多级缓存分布式锁的实现原理原理是使用命令来实现但是会有一系列问题任务时常超过缓存时间锁自动释放可以使用看门狗解决加锁和释放锁的不是同一线程可以在中存入删除时进行验证但是要注意验证锁和删除锁也不是一个原子性操作可以用脚本使之成为原子性操作不可重入可以使用解决实现机制类似计数集群下主节点宕机导致锁丢失使用红锁解决集群方案主从模式个节点多个节点节点宕机自动变成主节点哨兵模式在主从集群基础上添加哨兵节点或哨兵集群用于监控节点健康状态通过投票机制选择成为主节点分片集群主从模式和哨兵模式解决了并发读的问题但没有解决并发写的问题因此有了分片集群分片集群有多个节点并且不同保存不同的数据之间通过相互监测健康状态客户端请求任意一个节点都会转发到正确节点因为每个都被映射到个插槽上集群的是根据的值与插槽绑定集群主从同步原理主从同步第一次是全量同步第一次请求节点会根据判断是否是第一次同步是的话会生成发送给后续为增量同步在发送期间会产生一个缓存区间记录发送期间产生的新的命令节点在加载完后会持续读取缓存区间中的数据缓存一致性解决方案缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序先删除缓存后更新数据库存在的问题是可能会数据不一致一般使用延时双删来解决即先删除缓存再更新数据库休眠秒后再次淘汰缓存第二次删除可能导致吞吐率降低可以考虑进行异步删除先更新数据库后删除缓存存在的问题是会可能会更新失败可以采用延时删除但由于读比写快发生这一情况概率较小但是无论哪种策略都可能存在删除失败的问题解决方案是用中间件订阅日志提取需要删除的然后另写一段非业务代码去获取并尝试删除若删除失败就把删除失败的发送到消息队列然后进行删除重试内存淘汰策略当内存不足时按设定好的策略进行淘汰策略有淘汰最久没使用的淘汰一段时间内最少使用的淘汰快要过期的七计算机网络系列模型浏览器输入地址后做了什么三次握手为什么不能两次握手假设是两次握手若客户端发起的连接请求阻塞在网络中会造成该报文的重传这时服务收到连接请求后会立刻进入连接状态当双方传输完数据结束连接后第一次阻塞的请求突然又到达了服务端此时服务端又进入连接状态而客户端不会响应服务端的连接确认报文四次挥手为什么要进入时间等待状态若客户端发送确认释放包后直接关闭而服务端因为某种原因没有收到客户端的确认释放包就会一直发送确认请求而客户端永远不会再响应该请求滑动窗口流量控制主要使用滑动窗口协议滑动窗口是接受数据端使用的窗口大小用来告诉发送端接收端的缓存大小以此可以控制发送端发送数据的大小从而达到流量控制的目的如果发送方收到接收方的零窗口通知后会启动持续计时器计时器超时后向接收方发送零窗口探测报文如果响应仍为就重新计时不为就打破死锁拥塞控制发送方会维护一个拥塞窗口大小的状态变量大小取决于网络的拥塞程度发送方的发送窗口大小是取接收方接收窗口和拥塞窗口中较小的一个拥塞控制有四种算法慢开始从小到大主键发送窗口每收到一个确认报文窗口大小指数增长拥塞避免当窗口大小到达一定阈值时转为拥塞避免每收到一个确认报文窗口大小若此时网络超时就把阈值调小一半重新慢开始快重传要求接收方收到请求后要立即回复快恢复发送方连续收到多个确认时就把拥塞避免阈值减小然后直接开始拥塞避免超时重传发送方在发送按数据后一定时间内没有收到接收方响应报文就会重新发送刚刚的报文接收到收到报文后会对该报文的序列号进行检验已存在就抛弃可靠传输的实现是靠滑动窗口协议和连续协议配合流量控制和拥塞控制来保证的可靠传输是停止等待协议和自动重传请求它规定要为每一次传输的包编号每发送一个包要等待对方确认后才能发送下一个分组若一段时间对方没有确认就重新发送刚刚的报文接收方会对数据包排序把有序数据传给应用层返回缺失的第一个确认序列号给发送方接收到收到报文后会对该报文的序列号进行检验重复就丢弃流量控制是拥塞窗口上上面已经说了报头有哪些信息状态码请求正在处理请求成功处理请求重定向永久重定向临时重定向使用本地缓存客户端错误请求格式错误没有访问权限请求体过大服务端错误与的区别通信流程服务端创建并调用方法绑定和端口号服务端调用方法建立监听此时服务的还没有打开客户端创建并调用方法像服务端请求连接服务端监听到客户端请求后被动打开调用方法接收客户端连接请求当方法接收到客户端方法返回的响应成功的信息后连接成功客户端向写入请求信息服务端读取信息客户端调用结束链接服务端监听到释放连接请求后也结束链接八系列常用命令查看网络接口详情查看与某主机是否能联通进程名称查看进程号端口查看端口占用情况查看系统负载情况包括系统时间系统所有进程状态情况查看内存占用情况正常杀死进程发出的信号可能会被阻塞强制杀死进程发送的是命令不会被阻塞的模型是对磁盘或网络数据的读写用户进程读取一次请求分为两个阶段等待数据到达内核缓冲区和将内核缓冲区数据拷贝到用户空间当用户去内核中拷贝数据时要从用户态转为核心态中模型同步阻塞模型用户进程发起调用后会被阻塞等待内核缓冲区数据准备完毕时就被唤醒将内核数据复制到用户进程这两个阶段都是阻塞的同步非阻塞模型用户进程发起调用后若内核缓冲区数据还未准备好进程会继续干别的事每隔一段时间就去看看内核数据是否准备好不过将内核数据复制到用户进程这个阶段依旧是阻塞的多路复用模型中把一切都看成文件每个文件都有一个文件描述符来关联多路复用模型就是复用单个进程同时监测多个文件描述符当某个文件描述符可读或可写就去通知用户进程信号模型用户进程发起调用后会向内核注册一个信号处理函数然后继续干别的事当内核数据准备就绪时就通知用户进程来进行拷贝异步非阻塞模型前面四种全是同步的进程在发起调用后会直接返回结果待内核数据准备好时由内核将数据复制给用户进程两个阶段都是非阻塞的多路复用详解中把一切都看成文件每个文件都有一个文件描述符来关联多路复用模型就是复用单个进程同时监测多个文件描述符当某个文件描述符可读或可写就去通知用户进程多路复用有三种方式采用数组结构监测的有限默认为当有文件描述符就绪时需要遍历整个数组来查看是哪个文件描述符就绪了效率较低每次调用时都需要把整个文件描述符数组从用户态拷贝到内核态中来回拷贝当很多时开销会很大采用链表结构监测的文件描述符没有上限其它的根差不多采用红黑树结构监测的没有上限它有三个方法用于创建一个实例实例中有一颗红黑树记录监测的一个链表记录就绪的用于往实例中增删要监测的文件描述符并设置回调函数当文件描述符就绪时触发回调函数将文件描述符添加到就绪链表当中用于见擦汗就绪列表并返回就绪列表的长度然后将就绪列表的拷贝到用户空间缓冲区中所以的优点是当有文件描述符就绪时只把已就绪的文件描述符写给用户空间不需要每次都遍历集合每个只有在调新增的时候和就绪的时候才会在用户空间和内核空间之间拷贝一次的和模式默认水平触发当有数据可读的时候那么每次都会去通知用户来操作直到读完边缘触发当有数据可读的时候它只会通知用户一次直到下次再有数据流入才会再通知所以在模式下一定要把缓冲区的数据一次读完").trim().substring(0, num)

      const queryParams = `key=${options.key}&content=${truncateDescription}`;
      const requestOptions = {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Referer: options.Referer
        },
      };
      try {
        let animationInterval = null
        if (animationInterval) clearInterval(animationInterval);
        animationInterval = setInterval(() => {
          const animationText = "生成中" + ".".repeat(j);
          explanation.innerHTML = animationText;
          j = (j % 3) + 1; // 在 1、2、3 之间循环
        }, 500);
        const response = await fetch(`https://summary.tianli0.top/?${queryParams}`, requestOptions);
        let result;
        if (response.status === 403) {
          result = {
            summary: "403 refer与key不匹配，本地无法显示。"
          }
        } else if (response.status === 500) {
          result = {
            summary: "500 系统内部错误"
          }
        } else {
          result = await response.json();
        }
        const summary = result.summary.trim();
        setTimeout(() => {
          aiTitleRefreshIcon.style.opacity = "1";
        }, 300)
        startAI(summary);
        clearInterval(animationInterval)
      } catch (error) {
        console.error(error);
        explanation.innerHTML = "发生异常" + error;
      }
    } else {
      const strArr = "本教程介绍了JAVA面试中常问的问题".split(",").map(item => item.trim()); // 将字符串转换为数组，去除每个字符串前后的空格
      if (strArr.length !== 1) {
        let randomIndex = Math.floor(Math.random() * strArr.length); // 随机生成一个索引
        while (randomIndex === lastAiRandomIndex) { // 如果随机到了上次的索引
          randomIndex = Math.floor(Math.random() * strArr.length); // 再次随机
        }
        lastAiRandomIndex = randomIndex; // 更新上次随机到的索引
        startAI(strArr[randomIndex]);
      } else {
        startAI(strArr[0])
      }
      setTimeout(() => {
        aiTitleRefreshIcon.style.opacity = "1";
      }, 600)
    }
  }

  function aiRecommend() {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    explanation.innerHTML = "生成中. . .";
    ai_str = "";
    ai_str_length = "";
    observer.disconnect(); // 暂停上一次监听
    sto[2] = setTimeout(() => {
      explanation.innerHTML = recommendList();
    }, 600);
  }
  function aiGoHome() {
    startAI("正在前往博客主页...", false);
    sto[2] = setTimeout(() => {
      pjax.loadUrl("/");
    }, 1000);
  }
  const ai_btn_item = document.querySelectorAll(".ai-btn-item");
  function Introduce() {
    if (mode == "tianli") {
      startAI("我是文章辅助AI: TianliGPT，点击下方的按钮，让我生成本文简介、推荐相关文章等。")
    } else {
      startAI("我是文章辅助AI: AnZhiYu GPT，点击下方的按钮，让我生成本文简介、推荐相关文章等。")
    }
  }
  function aiTitleRefreshIconClick() {
    aiTitleRefreshIcon.click()
  }
  const aiFunctions = [Introduce, aiTitleRefreshIconClick, aiRecommend, aiGoHome];
  ai_btn_item.forEach((item, index) => {
    item.addEventListener("click", () => {
      aiFunctions[index]();
    });
  });

  function recommendList() {
    let thumbnail = document.querySelectorAll('.relatedPosts-list a');
    if (!thumbnail.length) {
      const cardRecentPost = document.querySelector('.card-widget.card-recent-post'); 
      if (!cardRecentPost) return '';

      thumbnail = cardRecentPost.querySelectorAll('.aside-list-item a');

      let list = '';
      for (let i = 0; i < thumbnail.length; i++) {
        const item = thumbnail[i];
        list += `<div class="ai-recommend-item"><span class="index">${i + 1}：</span><a href="javascript:;" onclick="pjax.loadUrl('${item.href}')" title="${item.title}" data-pjax-state="">${item.title}</a></div>`;
      }
      
      return `很抱歉，无法找到类似的文章，你也可以看看本站最新发布的文章：<br /><div class="ai-recommend">${list}</div>`;
    }

    let list = '';
    for (let i = 0; i < thumbnail.length; i++) {
      const item = thumbnail[i];
      list += `<div class="ai-recommend-item"><span>推荐${i + 1}：</span><a href="javascript:;" onclick="pjax.loadUrl('${item.href}')" title="${item.title}" data-pjax-state="">${item.title}</a></div>`;
    }

    return `推荐文章：<br /><div class="ai-recommend">${list}</div>`;
  }


  function changeShowMode() {
    if (mode === "tianli") {
      mode = "local";
      document.getElementById("ai-tag").innerHTML = "AnZhiYu GPT";
      aiAbstract(1000);
    } else {
      mode = "tianli";
      document.getElementById("ai-tag").innerHTML = "Tianli GPT";

      const truncateDescription = ("" + "三、高并发, 一、JAVA基础篇, 1.接口和抽象类的区别, 2.重载和重写的区别, 3.x3Dx3D和equals的区别, 4.异常处理机制, 5.HashMap原理, 6.想要线程安全的HashMap怎么办？, 7.ConcurrentHashMap原如何保证的线程安全？, 8.HashTable与HashMap的区别, 9.ArrayList和LinkedList的区别, 10.如何保证ArrayList的线程安全？, 11.String、StringBuffer、StringBuilder的区别, 12.hashCode和equals, 13.面向对象和面向过程的区别, 4.深拷贝和浅拷贝, 15.多态的作用, 16.什么是反射？, 17.Java创建对象得五种方式?, 二.Java多线程篇, 1.进程和线程的区别进程间如何通信, 2. 什么是线程上下文切换, 3.什么是死锁, 4.死锁的必要条件, 5.Synchrpnized和lock的区别, 6.什么是AQS锁?, 8.有哪些常见的AQS锁, 10.yield()和join()区别, 11.线程池七大参数, 12.Java内存模型, 13.保证并发安全的三大特性？, 14.volatile, 15.线程使用方式, 16.ThreadLocal原理, 17.什么是CAS锁, 18.Synchronized锁原理和优化, 19.如何根据 CPU 核心数设计线程池线程数量, 20.AtomicInteger的使用场景, 三.JVM篇, 1.JVM运行时数据区（内存结构）, 2.什么情况下会内存溢出？, 3.JVM有哪些垃圾回收算法？, 4.GC如何判断对象可以被回收？, 5.典型垃圾回收器, 6.类加载器和双亲委派机制, 7.JVM中有哪些引用？, 8.类加载过程, 9.JVM类初始化顺序, 10..对象的创建过程, 11.对象头中有哪些信息, 12.JVM内存参数, 13.GC的回收机制和原理, 四.Mysql篇, 1.MyIsAm和InnoDB的区别, 2.mysql事务特性, 3.事务靠什么保证, 4.事务的隔离级别, 5.什么是快照读和当前读, 6.MVCC是什么, 7.MySQL有哪些索引, 8.聚簇索引和非聚簇索引的区别, 9.MySQL如何做慢SQL优化, 10.为什么要用内连接而不用外连接？, 11.MySQL整个查询的过程, 12.执行计划中有哪些字段？, 13.哪些情况索引会失效, 14.B和B+数的区别为什么使用B+数, 15.MySQL有哪些锁, 16.Mysql内连接、左连接、右连接的区别, 17.sql执行顺序, 18.如何设计数据库？, 19.where和having的区别？, 20.三大范式, 21.char和varchar的区别, 22.InnoDB 什么情况下会产生死锁, 23.MySQL 删除自增 id随后重启 MySQL 服务再插入数据自增 id 会从几开始？, 24.MySQL插入百万级的数据如何优化？, 五.常用开发框架系列, 1.什么是Spring？, 2.IOC是什么？, 3.AOP是什么？, 4.如何定义一个全局异常处理类？, 5.如何使用aop自定义日志？, 6.循环依赖是什么怎么解决的？, 7.Bean 的作用域, 8.Bean 生命周期, 9.Spring 事务原理？, 10.spring事务失效场景, 11.spring事务的隔离级别, 12.spring事务的传播行为, 13.Spring IoC, 12.spring用了哪些设计模式, 14.SpringMV工作原理, 15.springboot自动配置原理, 16 .springboot常用注解, 17.spring的bean是线程安全的吗？, 18.springcloud主要解决什么问题？, 19.CAP理论, 20.为什么不能同时保证一致性和可用性呢？, 21.熔断限流的理解？, 22.常用限流算法, , 六.Redis系列, 1.redis为什么快？, 2.redis持久化机制, 3.Redis如何实现key的过期删除？, 4.Redis数据类型应用场景, 5.Redis缓存穿透如何解决？, 6.Redis如何解决缓存击穿？, 7.Redis如何解决缓存雪崩？, 8.Redis分布式锁的实现原理, 9.Redis集群方案, 10.Redis集群主从同步原理, 11.Redis缓存一致性解决方案, 12.Redis内存淘汰策略, 七.计算机网络系列, 1.TCPx2FIP模型, 2.浏览器输入地址后做了什么？, 3.TCP三次握手, 4.为什么TCP不能两次握手, 5.TCP四次挥手, 6.为什么要进入时间等待状态？, 7.TCP 滑动窗口, 8.TCP拥塞控制, 9.TCP超时重传, 10.TCP可靠传输的实现, 11.TCP报头有哪些信息, 12.状态码, 13.http与https的区别, 14.socket通信流程, 八.linux系列, 1.linux常用命令, 2.linux的io模型, 4.IO多路复用详解, 5.epoll的LT和ET模式什么是语言有哪些特点和有什么区别说说什么是跨平台性原理是什么什么是字节码采用字节码的好处是什么为什么说语言编译与解释并存有哪些数据类型自动类型转换强制类型转换看看这几行代码什么是自动拆箱封箱和有什么区别是否能作用在上的区别及作用用最有效率的方法计算乘以说说自增自减运算看下这几个代码运行结果向对象和向过程的区别面向对象有哪些特性重载和重写的区别访问修饰符以及不写默认时的区别关键字有什么作用抽象类和接口有什么区别三高并发并行与并发的区别什么是进程和线程进程系统进行资源分配调度的基本单位线程是进程的一个执行路径一个进程至少有一个线程同一一进程多个线程共享进程的资源操作系统分配资源是给进程的资源是给现成的比如启动函数就是启动了一个进程函数就是一个主线程说说线程有几种创建方式继承类重写方法调用实现接口重写方法实现接口重写方法为什么调用方法时会执行方法那怎么不直接调用方法执行方法会先创建一条线程由创建出来的新线程去执行的方法这才起到多线程的效果为什么我们不能直接调用方法也很清楚如果直接调用的方法那么方法还是运行在主线程中相当于顺序执行就起不到多线程的效果线程有哪些常用的调度方法类也提供了一个方法用于等待的方法如果一个线程执行了语句其含义是当前线程等待线程终止之后才从返回线程会暂时让出指定时间的执行权但是线程所拥有的监视器资源比如锁还是持有不让出的指定的睡眠时间到了后该函数会正常返回接着参与的调度获取到资源后就可以继续运行线程有几种状态什么是线程上下文切换使用多线程的目的是为了充分利用但是我们知道并发其实是一个来应付多个线程为了让用户感觉多个线程是在同时执行的资源的分配采用了时间片轮转也就是给每个线程分配一个时间片线程在时间片内占用执行任务当线程使用完时间片后就会处于就绪状态并让出让其他线程占用这就是上下文切换守护线程了解吗中的线程分为两类分别为线程守护线程和线程用户线程在启动时会调用函数函数所在的钱程就是一个用户线程其实在内部同时还启动了很多守护线程比如垃圾回收线程那么守护线程和用户线程有什么区别呢区别之一是当最后一个非守护线程束时会正常退出而不管当前是否存在守护线程也就是说守护线程是否结束并不影响退出换而言之只要有一个用户线程还没结束正常情况下就不会退出线程间有哪些通信方式和关键字关键字可以用来修饰字段成员变量就是告知程序任何对该变量的访问均需要从共享内存中获取而对它的改变必须同步刷新回共享内存它能保证所有线程对变量访问的可见性关键字可以修饰方法或者以同步块的形式来进行使用它主要确保多个线程在同一个时刻只能有一个线程处于方法或者同步块中它保证了线程对变量访问的可见性和排他性等待通知机制可以通过内置的等待通知机制实现一个线程修改一个对象的值而另一个线程感知到了变化然后进行相应的操作管道输入输出流管道输入输出流和普通的文件输入输出流或者网络输入输出流不同之处在于它主要用于线程之间的数据传输而传输的媒介为内存使用如果一个线程执行了语句其含义是当前线程等待线程终止之后才从返回线程除了提供方法之外还提供了和两个具备超时特性的方法使用即线程变量是一个以对象为键任意对象为值的存储结构这个结构被附带在线程上也就是说一个线程可以根据一个对象查询到绑定在这个线程上的一个值可以通过方法来设置一个值在当前线程下再通过方法获取到原先设置的值是什么也就是线程本地变量如果你创建了一个变量那么访问这个变量的每个线程都会有这个变量的一个本地拷贝多个线程操作这个变量的时候实际是操作自己本地内存里面的变量从而起到线程隔离的作用避免了线程安全问题一基础篇接口和抽象类的区别相似点接口和抽象类都不能被实例化实现接口或继承抽象类的普通子类都必须实现这些抽象方法不同点抽象类可以包含普通方法和代码块接口里只能包含抽象方法静态方法和默认方法抽象类可以有构造方法而接口没有抽象类中的成员变量可以是各种类型的接口的成员变量只能是类型的并且必须赋值重载和重写的区别重载发生在同一个类中方法名相同参数列表返回类型权限修饰符可以不同重写发生在子类中方法名相参数列表返回类型都相同权限修饰符要大于父类方法声明异常范围要小于父类方法但是和修饰的方法不可重写和的区别比较基本类型比较的是值比较引用类型比较的是内存地址是类的方法本质上与一样但是有些类重写了方法比如的被重写后比较的是字符值另外重写了后也必须重写方法异常处理机制使用捕获异常中的代码一定会执行捕获异常后程序会继续执行使用声明该方法可能会抛出的异常类型出现异常后程序终止原理在以后是基于数组链表红黑树来实现的特点是不能重复可以为线程不安全的扩容机制的默认容量为默认的负载因子为当中元素个数超过容量乘以负载因子的个数时就创建一个大小为前一次两倍的新数组再将原来数组中的数据复制到新数组中当数组长度到达且链表长度大于时链表转为红黑树存取原理计算的值然后进行二次根据二次结果找到对应的索引位置如果这个位置有值先进性比较若结果为则取代该元素若结果为就使用高低位平移法将节点插入链表以前使用头插法但是头插法在并发扩容时可能会造成环形链表或数据丢失而高低位平移发会发生数据覆盖的情况想要线程安全的怎么办使用使用方法原如何保证的线程安全使用分段锁将一个分为了个段每个段都是一个小的每次操作只对其中一个段加锁采用保证线程安全每次插入数据时判断在当前数组下标是否是第一次插入是就通过方式插入然后判断是否是的话就说明其他线程正在进行扩容当前线程也会参与扩容删除方法用了修饰保证并发下移除元素安全与的区别的每个方法都用修饰因此是线程安全的但同时读写效率很低的不允许为只对进行一次进行了两次底层使用的数组加链表和的区别的底层使用动态数组默认容量为当元素数量到达容量时生成一个新的数组大小为前一次的倍然后将原来的数组过来因为数组在内存中是连续的地址所以查找数据更快由于扩容机制添加数据效率更低的底层使用链表在内存中是离散的没有扩容机制在查找数据时需要从头遍历所以查找慢但是添加数据效率更高如何保证的线程安全使用方法为加锁使用底层与相同但是每个方法都由修饰速度很慢使用下的该类实现了读操作不加锁写操作时为创建一个副本期间其它线程读取的都是原本写操作都在副本中进行写入完成后再将指针指向副本的区别由数组构成使用了修饰对进行改变时每次都会新生成一个对象然后把指针指向新的引用对象可变并且线程安全可变但线程不安全操作少量字符数据用单线程操作大量数据用多线程操作大量数据用和和都是类的方法默认是通过地址来计算码但是可能被重写过用内容来计算码默认通过地址判断两个对象是否相等但是可能被重写用内容来比较两个对象所以两个对象相等他们的和一定相等但是相等的两个对象未必相等如果重写必须重写比如在中如果是类型如果只重写了而没有重写的话则两个比较为的因为不同导致两个没有出现在一个索引上就会出现中存在两个相同的面向对象和面向过程的区别面向对象有封装继承多态性的特性所以相比面向过程易维护易复用易扩展但是因为类调用时要实例化所以开销大性能比面向过程低深拷贝和浅拷贝浅拷贝浅拷贝只复制某个对象的引用而不复制对象本身新旧对象还是共享同一块内存深拷贝深拷贝会创造一个一摸一样的对象新对象和原对象不共享内存修改新对象不会改变原对对象多态的作用多态的实现要有继承重写父类引用指向子类对象它的好处是可以消除类型之间的耦合关系增加类的可扩充性和灵活性什么是反射反射是通过获取类的对象然后动态的获取到这个类的内部结构动态的去操作类的属性和方法应用场景有要操作权限不够的类属性和方法时实现自定义注解时动态加载第三方包时按需加载类节省编译和初始化时间获取对象的方法有类路径类对象的创建对象得五种方式关键字方法反序列化二多线程篇进程和线程的区别进程间如何通信进程系统运行的基本单位进程在运行过程中都是相互独立但是线程之间运行可以相互影响线程独立运行的最小单位一个进程包含多个线程且它们共享同一进程内的系统资源进程间通过管道共享内存信号量机制消息队列通信什么是线程上下文切换当一个线程被剥夺使用权时切换到另外一个线程执行什么是死锁死锁指多个线程在执行过程中因争夺资源造成的一种相互等待的僵局死锁的必要条件互斥条件同一资源同时只能由一个线程读取不可抢占条件不能强行剥夺线程占有的资源请求和保持条件请求其他资源的同时对自己手中的资源保持不放循环等待条件在相互等待资源的过程中形成一个闭环想要预防死锁只需要破坏其中一个条件即可比如使用定时锁尽量让线程用相同的加锁顺序还可以用银行家算法可以预防死锁和的区别是关键字是一个类在发生异常时会自动释放锁需要手动释放锁是可重入锁非公平锁不可中断锁的是可重入锁可中断锁可以是公平锁也可以是非公平锁是层次通过监视器实现的是通过实现的什么是锁是一个抽象类可以用来构造锁和同步类如的原理是内部有三个核心组件一个是代表加锁状态初始值为一个是获取到锁的线程还有一个阻塞队列当有线程想获取锁时会以的形式将变为成功后便将加锁线程设为自己当其他线程来竞争锁时会判断是不是不是再判断加锁线程是不是自己不是的话就把自己放入阻塞队列这个阻塞队列是用双向链表实现的可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己是的话释放锁的时候就将当减到的时候就去唤醒阻塞队列的第一个线程为什么使用的双向链表因为有一些线程可能发生中断而发生中断时候就需要在同步阻塞队列中删除掉这个时候用双向链表方便删除掉中间的节点有哪些常见的锁分为独占锁和共享锁独占锁可重入可中断可以是公平锁也可以是非公平锁非公平锁就是会通过两次去抢占锁公平锁会按队列顺序排队信号量设定一个信号量当调用时判断是否还有信号有就获取一个信号量没有就阻塞等待其他线程释放信号量当调用时释放一个信号量唤醒阻塞线程应用场景允许多个线程访问某个临界资源时如上下车买卖票倒计数器给计数器设置一个初始值当调用时计数器减一当调用时判断计数器是否归不为就阻塞直到计数器为应用场景启动一个服务时主线程需要等待多个组件加载完毕之后再继续执行循环栅栏给计数器设置一个目标值当调用时会计数并判断计数器是否达到目标值未达到就阻塞直到计数器达到目标值应用场景多线程计算数据最后合并计算结果的应用场景和的区别是的方法是类的方法会释放锁不会释放锁要在同步方法或者同步代码块中执行没有限制要调用或唤醒自动唤醒和区别调用后线程进入就绪状态线程中调用线程的则执行完前进入阻塞状态线程池七大参数核心线程数线程池中的基本线程数量最大线程数当阻塞队列满了之后逐一启动最大线程的存活时间当阻塞队列的任务执行完后最大线长的回收时间最大线程的存活时间单位阻塞队列当核心线程满后后面来的任务都进入阻塞队列线程工厂用于生产线程任务拒绝策略阻塞队列满后拒绝任务有四种策略抛异常丢弃任务不抛异常打回任务尝试与最老的线程竞争内存模型内存模型屏蔽了各种硬件和操作系统的内存访问差异实现让程序在各平台下都能达到一致的内存访问效果它定义了如何将程序中的变量在主存中读取具体定义为所有变量都存在主存中主存是线程共享区域每个线程都有自己独有的工作内存线程想要操作变量必须从主从中变量到自己的工作区每个线程的工作内存是相互隔离的由于主存与工作内存之间有读写延迟且读写不是原子性操作所以会有线程安全问题保证并发安全的三大特性原子性一次或多次操作在执行期间不被其他线程影响可见性当一个线程在工作内存修改了变量其他线程能立刻知道有序性对指令的优化会让指令执行顺序改变有序性是禁止指令重排保证变量的可见性和有序性不保证原子性使用了修饰变量后在变量修改后会立即同步到主存中每次用这个变量前会从主存刷新单例模式双重校验锁变量为什么使用修饰禁止指令重排序分为三个步骤为实例对象分配内存用构造器初始化成员变量将实例对象引用指向分配的内存实例对象在分配内存后实才不为如果分配内存后还未初始化就先将实例对象指向了内存那么此时最外层的会判断实例对象已经不等于就直接将实例对象返回而此时初始化还没有完成线程使用方式继承类实现接口实现接口带有返回值线程池创建线程原理原理是为每个线程创建变量副本不同线程之间不可见保证线程安全每个线程内部都维护了一个为实例为要保存的副本但是使用会存在内存泄露问题因为为弱引用而为强引用每次时都会回收而不会被回收所以为了解决内存泄漏问题可以在每次使用完后删除或者使用修饰可以随时获取什么是锁锁可以保证原子性思想是更新内存时会判断内存值是否被别人修改过如果没有就直接更新如果被修改就重新获取值直到更新完成为止这样的缺点是只能支持一个变量的原子操作不能保证整个代码块的原子操作频繁失败导致开销大问题线程和线程同时去修改一个变量将值从改为但线程突然阻塞此时线程将改为然后线程又将改成此时线程将又改为这个过程线程是不知道的这就是问题可以通过版本号或时间戳解决锁原理和优化是通过对象头的来表明监视器的监视器本质是依赖操作系统的互斥锁实现的操作系统实现线程切换要从用户态切换为核心态成本很高此时这种锁叫重量级锁在以后引入了偏向锁轻量级锁重量级锁偏向锁当一段代码没有别的线程访问此时线程去访问会直接获取偏向锁轻量级锁当锁是偏向锁时有另外一个线程来访问会升级为轻量级锁线程会通过方式获取锁不会阻塞提高性能重量级锁轻量级锁自旋一段时间后线程还没有获取到锁会升级为重量级锁重量级锁时来竞争锁的所有线程都会阻塞性能降低注意锁只能升级不能降级如何根据核心数设计线程池线程数量密集型线程中十分消耗的线程数密集型线程数量的使用场景是一个提供原子操作的类使用实来现线程安全的数值操作因为禁止了的排序优化所以它不适合在并发量小的时候使用只适合在一些高并发程序中使用三篇运行时数据区内存结构线程私有区虚拟机栈每次调用方法都会在虚拟机栈中产生一个栈帧每个栈帧中都有方法的参数局部变量方法出口等信息方法执行完毕后释放栈帧本地方法栈为修饰的本地方法提供的空间在中与虚拟机合二为一程序计数器保存指令执行的地址方便线程切回后能继续执行代码线程共享区堆内存进行垃圾回收的主要区域存放对象信息分为新生代和老年代内存比例为新生代的区内存不够时时发生老年代内存不够时发生方法区存放类信息静态变量常量运行时常量池等信息之前用持久代实现后用元空间实现元空间使用的是本地内存而非在内存结构中什么情况下会内存溢出堆内存溢出当对象一直创建而不被回收时加载的类越来越多时虚拟机栈的线程越来越多时栈溢出方法调用次数过多一般是递归不当造成有哪些垃圾回收算法标记清除算法标记不需要回收的对象然后清除没有标记的对象会造成许多内存碎片复制算法将内存分为两块只使用一块进行垃圾回收时先将存活的对象复制到另一块区域然后清空之前的区域用在新生代标记整理算法与标记清除算法类似但是在标记之后将存活对象向一端移动然后清除边界外的垃圾对象用在老年代如何判断对象可以被回收引用计数法已淘汰为每个对象添加引用计数器引用为时判定可以回收会有两个对象相互引用无法回收的问题可达性分析法从开始往下搜索搜索过的路径称为引用链若一个对象没有任何的引用链则判定可以回收有虚拟机栈中引用的对象方法区中静态变量引用的对象本地方法栈中引用的对象典型垃圾回收器以最小的停顿时间为目标只运行在老年代的垃圾回收器使用标记清除算法可以并发收集以后的默认垃圾回收器注重响应速度支持并发采用标记整理复制算法回收内存使用可达性分析法来判断对象是否可以被回收类加载器和双亲委派机制从父类加载器到子类加载器分别为加载路径为加载路径为加载路径为还有一个自定义类加载器当一个类加载器收到类加载请求时会先把这个请求交给父类加载器处理若父类加载器找不到该类再由自己去寻找该机制可以避免类被重复加载还可以避免系统级别的类被篡改中有哪些引用强引用的对象哪怕内存溢出也不会回收软引用只有内存不足时才会回收弱引用每次垃圾回收都会回收虚引用必须配合引用队列使用一般用于追踪垃圾回收动作类加载过程加载把字节码通过二进制的方式转化到方法区中的运行数据区连接验证验证字节码文件的正确性准备正式为类变量在方法区中分配内存并设置初始值类型的变量在编译时已经赋值了解析将常量池中的符号引用如类的全限定名解析为直接引用类在实际内存中的地址初始化执行类构造器不是常规的构造方法为静态变量赋初值并初始化静态代码块类初始化顺序父类静态代码块和静态成员变量子类静态代码块和静态成员变量父类代码块和普通成员变量父类构造方法子类代码块和普成员变量子类构造方法对象的创建过程检查类是否已被加载没有加载就先加载类为对象在堆中分配内存使用方式分配防止在为分配内存时执行当前地址的指针还没有来得及修改对象就拿来分配内存初始化将对象中的属性都分配值或设置对象头为属性赋值和执行构造方法对象头中有哪些信息对象头中有两部分一部分是存储对象运行时的数据如对象的分代年龄标记锁的状态获取到锁的线程等另外一部分是表明对象所属类如果是数组还有一个部分存放数组长度内存参数堆空间最大内存堆空间最小内存一般设置成跟堆空间最大内存一样的新生代的最大内存区与区的比例为默认为垃圾回收器名称指定垃圾回收器设置单个线程栈大小一般设堆空间为最大可用物理地址的百分之的回收机制和原理的目的实现内存的自动释放使用可达性分析法判断对象是否可回收采用了分代回收思想将堆分为新生代老年代新生代中采用复制算法老年代采用整理算法当新生代内存不足时会发生老年代不足时会发送四篇和的区别有三大特性分别是事务外键行级锁这些都是不支持的另外是聚簇索引是非聚簇索引不支持全文索引支持支持自增和模式的读写不支持的访问速度一般快差异在于的行锁会比较消耗性能还可能有回表的过程先去辅助索引中查询数据找到数据对应的之后再通过回表到聚簇索引树查找数据事务特性原子性一个事务内的操作统一成功或失败一致性事务前后的数据总量不变隔离性事务与事务之间相互不影响持久性事务一旦提交发生的改变不可逆事务靠什么保证原子性由日志保证他记录了需要回滚的日志信息回滚时撤销已执行的一致性由其他三大特性共同保证是事务的目的隔离性由保证持久性由日志和内存保证修改数据时内存和会记录操作宕机时可恢复事务的隔离级别在高并发情况下并发事务会产生脏读不可重复读幻读问题这时需要用隔离级别来控制读未提交允许一个事务读取另一个事务已提交的数据可能出现不可重复读幻读读提交只允许事务读取另一个事务没有提交的数据可能出现不可重复读幻读可重复读确保同一字段多次读取结果一致可能出现欢幻读可串行化所有事务逐次执行没有并发问日默认隔离级别为可重复读级别分为快照度和当前读并且通过间隙锁解决了幻读问题什么是快照读和当前读快照读读取的是当前数据的可见版本可能是会过期数据不加锁的就是快照都当前读读取的是数据的最新版本并且当前读返回的记录都会上锁保证其他事务不会并发修改这条记录如排他锁共享锁都是当前读是什么是多版本并发控制为每次事务生成一个新版本数据每个事务都由自己的版本从而不加锁就决绝读写冲突这种读叫做快照读只在读已提交和可重复读中生效实现原理由四个东西保证他们是日志记录了数据历史版本事务进行快照读时动态生成产生的视图记录了当前系统中活跃的事务控制哪个历史版本对当前事务可见隐藏字段最近修改记录的事务隐藏字段回滚指针配合指向数据的上一个版本有哪些索引主键索引一张表只能有一个主键索引主键索引列不能有空值和重复值唯一索引唯一索引不能有相同值但允许为空普通索引允许出现重复值组合索引对多个字段建立一个联合索引减少索引开销遵循最左匹配原则全文索引引擎支持通过建立倒排索引提升检索效率广泛用于搜索引擎聚簇索引和非聚簇索引的区别聚簇索引聚簇索引的叶子节点存放的是主键值和数据行辅助索引在聚簇索引上创建的其它索引的叶子节点存放的是主键值或指向数据行的指针优点根据索引可以直接获取值所以他获取数据更快对于主键的排序查找和范围查找效率更高缺点如果主键值很大的话辅助索引也会变得很大如果用作为主键数据存储会很稀疏修改主键或乱序插入会让数据行移动导致页分裂所以一般我们定义主键时尽量让主键值小并且定义为自增和不可修改非聚簇索引辅助索引叶子节点存放的是数据行地址先根据索引找到数据地址再根据地址去找数据他们都是数结构如何做慢优化可以查看执行计划分析数据的扫描类型索引是否生效常见的慢查询优化有尽量减少的数据列尽量使用覆盖索引查找时使用索引进行排序否则的话需要进行回表查询时同样要用索引避免使用到临时表分页查询时如果后面的数字太大可以使用子查询查出主键再主键后条数据就能走覆盖索引使用复杂查询时使用关联查询来代替子查询并且最好使用内连接使用函数时直接使用的话的效率最高或唯一索引或数字表中总记录数字段不会统计在写语句时条件要使用索引否则会锁会从行锁升级为表锁表中数据是否太大是不是要分库分表为什么要用内连接而不用外连接用外连接的话连接顺序是固定死的比如他必须先对左表进行全表扫描然后一条条到右表去匹配而内连接的话会自己根据查询优化器去判断用哪个表做驱动子查询的话同样也会对驱动表进行全表扫描所以尽量用小表做驱动表整个查询的过程客户端向服务器发送一条查询请求服务器首先检查查询缓存如果命中缓存则返回存储在缓存中的结果否则进入下一阶段服务器进行解析预处理再由优化器生成对应的执行计划根据执行计划调用存储引擎的来执行查询将结果返回给客户端同时缓存查询结果注意只有在之前才有查询缓存之后查询缓存被去掉了执行计划中有哪些字段我们想看一个的执行计划使用的语句是表中的字段包括扫描类型效率从底到高为全表扫描全索引扫描我们的需要的数据在索引中可以获取使用索引进行范围查找使用非唯一索引列进行了关联查询使用唯一索引进行关联查询使用唯一索引查询一行数据表中只有一行数据额外的如何查询额外信息常见的有在排序缓冲区中进行排序需要回表查询数据表示使用覆盖索引排序时使用了索引排序但如果是按照降序排序的话就会使用反向扫描索引查询时要建立一个临时表存放数据找到了多少行数据实际使用到的索引查询的优先级越大优先级越高子查询的一般会更大查询的类型是普通查询还是联合查询还是子查询常见类型有不包含子查询标记复杂查询中最外层的查询标记只后子查询者一行的数据是数哪张表的可能的当前查询语句可能用到的索引可能为如果用了索引但是为有可能是表数据太少认为全表扫描更快编号显示索引的哪一行被使用了哪些情况索引会失效条件中有除非所有查询条件都有索引否则失效查询用开头索引失效索引列参与计算索引失效违背最左匹配原则索引失效索引字段发生类型转换索引失效觉得全表扫描更快时数据少索引失效和数的区别为什么使用数二叉树索引字段有序极端情况会变成链表形式数树的高度不可控数控制了树的高度但是索引值和都分布在每个具体的节点当中若要进行范围查询要进行多次回溯开销大树非叶子节点只存储索引值叶子节点再存储索引具体数据从小到大用链表连接在一起范围查询可直接遍历不需要回溯有哪些锁基于粒度表级锁对整张表加锁粒度大并发小行级锁对行加锁粒度小并发大间隙锁间隙锁锁住表的一个区间间隙锁之间不会冲突只在可重复读下才生效解决了幻读基于属性共享锁又称读锁一个事务为表加了读锁其它事务只能加读锁不能加写锁排他锁又称写锁一个事务加写锁之后其他事务不能再加任何锁避免脏读问题内连接左连接右连接的区别内连接取量表交集部分左连接取左表全部右表匹部分右连接取右表全部坐表匹部分执行顺序如何设计数据库抽取实体如用户信息商品信息评论分析其中属性如用户信息姓名性别分析表与表之间的关联关系然后可以参考三大范式进行设计设计主键时主键要尽量小并且定义为自增和不可修改和的区别是约束声明是过滤声明早于执行并且不可以使用聚合函数可以三大范式第一范式每个列都不可以再拆分第二范式在第一范式的基础上非主键列完全依赖于主键而不能是依赖于主键的一部分第三范式在第二范式的基础上非主键列只依赖于主键不依赖于其他非主键和的区别是不可变的最大长度为是可变的字符串最大长度为什么情况下会产生死锁事务已经获取数据的写锁想要去获取数据的写锁然后事务获取了的写锁想要去获取的写锁相互等待形成死锁解决死锁的机制有两个等待直到超时发起死锁检测主动回滚一条事务死锁检测的原理是构建一个以事务为顶点锁为边的有向图判断有向图是否存在环存在即有死锁我们平时尽量减少事务操作的资源和隔离级别删除自增随后重启服务再插入数据自增会从几开始引擎前下次自增会取表中最大原理是最大会记录在内存中重启之后会重新读取表中最大的后仍从删除数据后算起原理是它将最大记录在里了自增的都从删除数据后算起原理是它将最大记录到数据文件里了插入百万级的数据如何优化一次插入多条数据可以减少写日志和日志的次数是有长度限制的但可以调整保证数据按照索引进行有序插入可以分表后多线程插入五常用开发框架系列什么是是个轻量级的框架通过达到松耦合的目的通过可以分离应用业务逻辑和系统服务进行内聚性的开发不过配置各种组件时比较繁琐所以后面才出选了的框架是什么是控制反转是一种思想把对象的创建和调用从程序员手中交由容器管理降低对象之间的依赖关系创建一个的方式有方式注解方式方式我们在对一个进行实例化后要对他的属性进行填充大多数我们都是使用直接的填充依赖注入的他是有限按照类型进行匹配是什么是面向切面编程可以将那些与业务不相关但是很多业务都要调用的代码抽取出来思想就是不侵入原有代码的情况下对功能进行增强是基于动态代理实现的动态代理是有两种一种是动态代理一种是动态代理动态代理是原理是利用反射来实现的需要调用反射包下的类的方法来返回代理对象这个方法中有三个参数分别是用于加载代理类的类加载器被代理类实现的接口的数组和一个用于增强方法的实现类动态代理原理是利用开源包来实现的是把被代理类的文件加载进来通过修改它的字节码生成子类来处理动态代理要求被代理类必须有实现的接口生成的动态代理类会和代理类实现同样的接口则生成的动态代理类会继承被代理类默认使用动态代理当被代理的类没有接口时就使用动态代理如何定义一个全局异常处理类想要定义一个全局异常处理类的话我们需要在这个类上添加注解然后定义一些用于捕捉不同异常类型的方法在这些方法上添加异常类型和注解方法参数是和异常类型然后将异常消息进行处理如果我们需要自定义异常的话就写一个自定义异常类该类需要继承一个异常接口类属性包括类型的连续错误码错误信息再根据需求写构造方法如何使用自定义日志第一步创建一个切面类把它添加到容器中并添加注解第二步在切面类中写一个通知方法在方法上添加通知注解并通过切入点表达式来表示要对哪些方法进行日志打印然后方法参数为第三步通过这个参数可以获取当前执行的方法名方法参数等信息这样就可以根据需求在方法进入或结束时打印日志循环依赖是什么怎么解决的循环依赖就是在创建实例的时候里面包含着属性实例所以这个时候就需要去创建实例而创建实例过程中也包含着实例这样实例还在创建的过程当中所以就导致和实例都创建不出来通过三级缓存来解决循环依赖一级缓存单例池缓存经过了已经初始化完毕的二级缓存半成品池缓存还未初始化完毕的三级缓存缓存的是获取的代理对象的表达式我们在创建的过程中先将放入三级缓存这时要创建要创建就直接去三级缓存中查找并且判断需不需要进行处理如果需要就在三级缓存中获取的代理对象不需要就取原始对象然后将取出的对象放入二级缓存中这个时候其他需要依赖对象的直接从二级缓存中去获取即可当初始化完成进入一级缓存后继续执行生命周期当完成了属性的注入后就可以放入一级缓存了之前默认会解决循环依赖在之后需要通过配置开启解决循环依赖的作用域一个容器只有一个每次调用都会生成一个新的对象每个请求都会创建一个自己的同一个共享一个实例整个只有一个一个只有一个生命周期实例化属性赋值初始化销毁在这四步的基础上面提供了一些拓展点自身的方法包括了本身调用的方法和通过配置文件中的和指定的方法级生命周期接口方法包括了和这些接口的方法容器级生命周期接口方法包括了和这两个接口实现一般称它们的实现类为后处理器工厂后处理器接口方法包括了等等非常有用的工厂后处理器接口的方法工厂后处理器也是容器级的在应用上下文装配配置文件之后立即调用事务原理事务有编程式和声明式我们一般使用声明式在某个方法上增加注解这个方法中的会统一成功或失败原理是当一个方法加上注解会基于这个类生成一个代理对象并将这个代理对象作为当使用这个中的方法时如果存在注解就会将事务自动提交设为然后执行方法执行过程没有异常则提交有异常则回滚事务失效场景事务方法所在的类没有加载到容器中事务方法不是类型同一类中一个没有添加事务的方法调用另外以一个添加事务的方法事务不生效事务默认只回滚运行时异常可以用属性设置业务自己捕获了异常事务会认为程序正常秩序事务的隔离级别默认级别使用数据库自定义的隔离级别其它四种隔离级别与一样事务的传播行为支持当前事务如果不存在则新启一个事务支持当前事务如果不存在则抛出异常支持当前事务如果不存在则以非事务方式执行不支持当前事务创建一个新事物不支持当前事务如果已存在事务就抛异常不支持当前事务始终以非事务方式执行用了哪些设计模式用了工厂模式用了动态代理模式用来模板方法模式中用来适配器模式里的监听器用了观察者模式工作原理工作过程围绕着前端控制器几个重要组件有处理器映射器处理器适配器试图解析器工作流程接收用户请求将请求发送给根据请求找到具体的和拦截器返回给调用执行具体的并将返回的返回给将传给解析后返回具体根据进行视图渲染返回给用户自动配置原理在包下存放了内置的自动配置类和文件这个文件中存放了这些配置类的全类名启动类注解下有三个关键注解表示启动类是一个自动配置类扫描启动类所在包下及子包的组件到容器中下面有个子注解会导入上面所说的自动配置类这些配置类会根据元注解的装配条件生效生效的类就会被实例化加载到容器中这些自动配置类还会通过文件里配置来进行属性设值常用注解修饰类该控制器会返回数据修饰类该控制器的请求路径修饰属性按照类型进行依赖注入修饰参数将路径值映射到参数上修饰方法该方法会返回数据需要使用提交方式修饰参数将数据封装到对应参数中将类注册到容器开启事务的是线程安全的吗的默认作用域是单例的单例的不是线程安全的但是开发中大部分的都是无状态的不具备存储功能比如他们不需要保证线程安全如果要保证线程安全可以将的作用域改为比如像另外还可以采用来解决线程安全问题为每个线程保存一个副本变量每个线程只操作自己的副本变量主要解决什么问题解决服务之间的通信容灾负载平衡冗余问题能方便服务集中管理常用组件有注册中心配置中心远程调用服务熔断网关理论一致性这里指的强一致性也就是数据更新完访问任何节点看到的数据完全一致可用性就是任何没有发生故障的服务必须在规定时间内返回合正确结果容灾性当网络不稳定时节点之间无法通信造成分区这时要保证系统可以继续正常服务提高容灾性的办法就是把数据分配到每一个节点当中所以是分布式系统必须实现的然后需要在和中取舍为什么不能同时保证一致性和可用性呢当网络发生故障时如果要保障数据一致性那么节点相互间就只能阻塞等待数据真正同步时再返回就违背可用性了如果要保证可用性节点要在有限时间内将结果返回无法等待其它节点的更新消息此时返回的数据可能就不是最新数据就违背了一致性了熔断限流的理解中用组件来进行降级熔断限流熔断是对于消费者来讲当对提供者请求时间过久时为了不影响性能就对链接进行熔断限流是对于提供者来讲为了防止某个消费者流量太大导致其它更重要的消费者请求无法及时处理限流可用通过拒绝服务服务降级消息队列延时处理限流算法来实现常用限流算法计数器算法使用的和过期机制实现漏桶算法一般使用消息队列来实现系统以恒定速度处理队列中的请求当队列满的时候开始拒绝请求令牌桶算法计数器算法和漏桶算法都无法解决突然的大并发令牌桶算法是预先往桶中放入一定数量然后用恒定速度放入直到桶满为止所有请求都必须拿到才能访问系统六系列为什么快完全基于内存操作数据结构简单对数据操作简单执行命令是单线程的避免了上下文切换带来的性能问题也不用考虑锁的问题采用了非阻塞的多路复用机制使用了单线程来处理并发的连接内部采用的自己实现的事件分离器其实不是完全多线程的在核心的网络模型中是多线程的用来处理并发连接但是数据的操作都是单线程坚持单线程是因为是的性能瓶颈是网络延迟而不是多线程对数据读取不会带来性能提升持久化机制快照持久化的默认持久化机制通过父进程一个子进程子进程将的数据快照写入一个临时文件等待持久化完毕后替换上一次的文件整个过程主进程不进行任何的操作持久化策略可以通过配置单位时间内执行多少次操作触发持久化所以的优点是保证性能最大化恢复速度数据较快缺点是可能会丢失两次持久化之间的数据追加持久化以日志形式记录每一次的写入和删除操作策略有每秒同步每次操作同步不同步优点是数据完整性高缺点是运行效率低恢复时间长如何实现的过期删除采用的定期过期惰性过期定期删除每隔一段时间从设置过期时间的集合中随机抽取一些检查是否过期如果已经过期做删除处理惰性删除在被访问的时候检查是否过期如果过期则删除数据类型应用场景可以用来缓存信息可以用命令实现自增或自减的计数器与一样可以保存信息可以用来做消息队列的是原子性操作能一定程度保证线程安全可以做去重比如一个用户只能参加一次活动可以做交集求共友有序的可以实现排行榜缓存穿透如何解决缓存穿透是指频繁请求客户端和缓存中都不存在的数据缓存永远不生效请求都到达了数据库解决方案在接口上做基础校验比如就拦截缓存空对象找不到的数据也缓存起来并设置过期时间可能会造成短期不一致布隆过滤器在客户端和缓存之间添加一个过滤器拦截掉一定不存在的数据请求如何解决缓存击穿缓存击穿是值一个非常热点在某一瞬间失效导致大量请求到达数据库解决方案设置热点数据永不过期给缓存重建的业务加上互斥锁缺点是性能低如何解决缓存雪崩缓存雪崩是值某一时间同时失效或宕机导致大量请求到达数据库解决方案搭建集群保证高可用进行数据预热给不同的设置随机的过期时间给缓存业务添加限流降级通过加锁或队列控制操作的线程数量给业务添加多级缓存分布式锁的实现原理原理是使用命令来实现但是会有一系列问题任务时常超过缓存时间锁自动释放可以使用看门狗解决加锁和释放锁的不是同一线程可以在中存入删除时进行验证但是要注意验证锁和删除锁也不是一个原子性操作可以用脚本使之成为原子性操作不可重入可以使用解决实现机制类似计数集群下主节点宕机导致锁丢失使用红锁解决集群方案主从模式个节点多个节点节点宕机自动变成主节点哨兵模式在主从集群基础上添加哨兵节点或哨兵集群用于监控节点健康状态通过投票机制选择成为主节点分片集群主从模式和哨兵模式解决了并发读的问题但没有解决并发写的问题因此有了分片集群分片集群有多个节点并且不同保存不同的数据之间通过相互监测健康状态客户端请求任意一个节点都会转发到正确节点因为每个都被映射到个插槽上集群的是根据的值与插槽绑定集群主从同步原理主从同步第一次是全量同步第一次请求节点会根据判断是否是第一次同步是的话会生成发送给后续为增量同步在发送期间会产生一个缓存区间记录发送期间产生的新的命令节点在加载完后会持续读取缓存区间中的数据缓存一致性解决方案缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序先删除缓存后更新数据库存在的问题是可能会数据不一致一般使用延时双删来解决即先删除缓存再更新数据库休眠秒后再次淘汰缓存第二次删除可能导致吞吐率降低可以考虑进行异步删除先更新数据库后删除缓存存在的问题是会可能会更新失败可以采用延时删除但由于读比写快发生这一情况概率较小但是无论哪种策略都可能存在删除失败的问题解决方案是用中间件订阅日志提取需要删除的然后另写一段非业务代码去获取并尝试删除若删除失败就把删除失败的发送到消息队列然后进行删除重试内存淘汰策略当内存不足时按设定好的策略进行淘汰策略有淘汰最久没使用的淘汰一段时间内最少使用的淘汰快要过期的七计算机网络系列模型浏览器输入地址后做了什么三次握手为什么不能两次握手假设是两次握手若客户端发起的连接请求阻塞在网络中会造成该报文的重传这时服务收到连接请求后会立刻进入连接状态当双方传输完数据结束连接后第一次阻塞的请求突然又到达了服务端此时服务端又进入连接状态而客户端不会响应服务端的连接确认报文四次挥手为什么要进入时间等待状态若客户端发送确认释放包后直接关闭而服务端因为某种原因没有收到客户端的确认释放包就会一直发送确认请求而客户端永远不会再响应该请求滑动窗口流量控制主要使用滑动窗口协议滑动窗口是接受数据端使用的窗口大小用来告诉发送端接收端的缓存大小以此可以控制发送端发送数据的大小从而达到流量控制的目的如果发送方收到接收方的零窗口通知后会启动持续计时器计时器超时后向接收方发送零窗口探测报文如果响应仍为就重新计时不为就打破死锁拥塞控制发送方会维护一个拥塞窗口大小的状态变量大小取决于网络的拥塞程度发送方的发送窗口大小是取接收方接收窗口和拥塞窗口中较小的一个拥塞控制有四种算法慢开始从小到大主键发送窗口每收到一个确认报文窗口大小指数增长拥塞避免当窗口大小到达一定阈值时转为拥塞避免每收到一个确认报文窗口大小若此时网络超时就把阈值调小一半重新慢开始快重传要求接收方收到请求后要立即回复快恢复发送方连续收到多个确认时就把拥塞避免阈值减小然后直接开始拥塞避免超时重传发送方在发送按数据后一定时间内没有收到接收方响应报文就会重新发送刚刚的报文接收到收到报文后会对该报文的序列号进行检验已存在就抛弃可靠传输的实现是靠滑动窗口协议和连续协议配合流量控制和拥塞控制来保证的可靠传输是停止等待协议和自动重传请求它规定要为每一次传输的包编号每发送一个包要等待对方确认后才能发送下一个分组若一段时间对方没有确认就重新发送刚刚的报文接收方会对数据包排序把有序数据传给应用层返回缺失的第一个确认序列号给发送方接收到收到报文后会对该报文的序列号进行检验重复就丢弃流量控制是拥塞窗口上上面已经说了报头有哪些信息状态码请求正在处理请求成功处理请求重定向永久重定向临时重定向使用本地缓存客户端错误请求格式错误没有访问权限请求体过大服务端错误与的区别通信流程服务端创建并调用方法绑定和端口号服务端调用方法建立监听此时服务的还没有打开客户端创建并调用方法像服务端请求连接服务端监听到客户端请求后被动打开调用方法接收客户端连接请求当方法接收到客户端方法返回的响应成功的信息后连接成功客户端向写入请求信息服务端读取信息客户端调用结束链接服务端监听到释放连接请求后也结束链接八系列常用命令查看网络接口详情查看与某主机是否能联通进程名称查看进程号端口查看端口占用情况查看系统负载情况包括系统时间系统所有进程状态情况查看内存占用情况正常杀死进程发出的信号可能会被阻塞强制杀死进程发送的是命令不会被阻塞的模型是对磁盘或网络数据的读写用户进程读取一次请求分为两个阶段等待数据到达内核缓冲区和将内核缓冲区数据拷贝到用户空间当用户去内核中拷贝数据时要从用户态转为核心态中模型同步阻塞模型用户进程发起调用后会被阻塞等待内核缓冲区数据准备完毕时就被唤醒将内核数据复制到用户进程这两个阶段都是阻塞的同步非阻塞模型用户进程发起调用后若内核缓冲区数据还未准备好进程会继续干别的事每隔一段时间就去看看内核数据是否准备好不过将内核数据复制到用户进程这个阶段依旧是阻塞的多路复用模型中把一切都看成文件每个文件都有一个文件描述符来关联多路复用模型就是复用单个进程同时监测多个文件描述符当某个文件描述符可读或可写就去通知用户进程信号模型用户进程发起调用后会向内核注册一个信号处理函数然后继续干别的事当内核数据准备就绪时就通知用户进程来进行拷贝异步非阻塞模型前面四种全是同步的进程在发起调用后会直接返回结果待内核数据准备好时由内核将数据复制给用户进程两个阶段都是非阻塞的多路复用详解中把一切都看成文件每个文件都有一个文件描述符来关联多路复用模型就是复用单个进程同时监测多个文件描述符当某个文件描述符可读或可写就去通知用户进程多路复用有三种方式采用数组结构监测的有限默认为当有文件描述符就绪时需要遍历整个数组来查看是哪个文件描述符就绪了效率较低每次调用时都需要把整个文件描述符数组从用户态拷贝到内核态中来回拷贝当很多时开销会很大采用链表结构监测的文件描述符没有上限其它的根差不多采用红黑树结构监测的没有上限它有三个方法用于创建一个实例实例中有一颗红黑树记录监测的一个链表记录就绪的用于往实例中增删要监测的文件描述符并设置回调函数当文件描述符就绪时触发回调函数将文件描述符添加到就绪链表当中用于见擦汗就绪列表并返回就绪列表的长度然后将就绪列表的拷贝到用户空间缓冲区中所以的优点是当有文件描述符就绪时只把已就绪的文件描述符写给用户空间不需要每次都遍历集合每个只有在调新增的时候和就绪的时候才会在用户空间和内核空间之间拷贝一次的和模式默认水平触发当有数据可读的时候那么每次都会去通知用户来操作直到读完边缘触发当有数据可读的时候它只会通知用户一次直到下次再有数据流入才会再通知所以在模式下一定要把缓冲区的数据一次读完").trim().substring(0, 1000);
      let value = Math.floor(Math.random() * 3) + 1000;
      while (value === prevParam || truncateDescription.length - value === prevParam) {
        value = Math.floor(Math.random() * 3) + 1000;
      }
      aiTitleRefreshIcon.style.opacity = "0.2";
      aiTitleRefreshIcon.style.transitionDuration = "0.3s";
      aiTitleRefreshIcon.style.transform = "rotate(" + 360 * refreshNum + "deg)";
      if (truncateDescription.length <= 1000) {
        let param = truncateDescription.length - Math.floor(Math.random() * 3);
        while (param === prevParam) {
          param = truncateDescription.length - Math.floor(Math.random() * 3);
        }
        aiAbstract(param);
        prevParam = param;
      } else {
        aiAbstract(value);
        prevParam = value;
      }
      refreshNum++;
    }
  }

  //- 监听tag点击事件
  document.getElementById("ai-tag").addEventListener("click", () => {
    if (mode === "tianli") {
      document.querySelectorAll(".ai-btn-item").forEach(item => item.style.display = "none");
      document.getElementById("go-tianli-blog").style.display = "block";
      startAI("你好，我是Tianli开发的摘要生成助理TianliGPT，是一个基于GPT-4的生成式AI。我在这里只负责摘要的预生成和显示，你无法与我直接沟通，如果你也需要一个这样的AI摘要接口，可以在下方购买。（暂未开放购买，敬请期待）")
    } else {
      document.getElementById("go-tianli-blog").style.display = "none";
      startAI("你好，我是本站摘要生成助理AnZhiYu GPT，是一个基于GPT-4的生成式AI。我在这里只负责摘要的预生成和显示，你无法与我直接沟通。")
    }

  });

  aiTitleRefreshIcon.addEventListener("click", () => {
    const truncateDescription = ("" + "三、高并发, 一、JAVA基础篇, 1.接口和抽象类的区别, 2.重载和重写的区别, 3.x3Dx3D和equals的区别, 4.异常处理机制, 5.HashMap原理, 6.想要线程安全的HashMap怎么办？, 7.ConcurrentHashMap原如何保证的线程安全？, 8.HashTable与HashMap的区别, 9.ArrayList和LinkedList的区别, 10.如何保证ArrayList的线程安全？, 11.String、StringBuffer、StringBuilder的区别, 12.hashCode和equals, 13.面向对象和面向过程的区别, 4.深拷贝和浅拷贝, 15.多态的作用, 16.什么是反射？, 17.Java创建对象得五种方式?, 二.Java多线程篇, 1.进程和线程的区别进程间如何通信, 2. 什么是线程上下文切换, 3.什么是死锁, 4.死锁的必要条件, 5.Synchrpnized和lock的区别, 6.什么是AQS锁?, 8.有哪些常见的AQS锁, 10.yield()和join()区别, 11.线程池七大参数, 12.Java内存模型, 13.保证并发安全的三大特性？, 14.volatile, 15.线程使用方式, 16.ThreadLocal原理, 17.什么是CAS锁, 18.Synchronized锁原理和优化, 19.如何根据 CPU 核心数设计线程池线程数量, 20.AtomicInteger的使用场景, 三.JVM篇, 1.JVM运行时数据区（内存结构）, 2.什么情况下会内存溢出？, 3.JVM有哪些垃圾回收算法？, 4.GC如何判断对象可以被回收？, 5.典型垃圾回收器, 6.类加载器和双亲委派机制, 7.JVM中有哪些引用？, 8.类加载过程, 9.JVM类初始化顺序, 10..对象的创建过程, 11.对象头中有哪些信息, 12.JVM内存参数, 13.GC的回收机制和原理, 四.Mysql篇, 1.MyIsAm和InnoDB的区别, 2.mysql事务特性, 3.事务靠什么保证, 4.事务的隔离级别, 5.什么是快照读和当前读, 6.MVCC是什么, 7.MySQL有哪些索引, 8.聚簇索引和非聚簇索引的区别, 9.MySQL如何做慢SQL优化, 10.为什么要用内连接而不用外连接？, 11.MySQL整个查询的过程, 12.执行计划中有哪些字段？, 13.哪些情况索引会失效, 14.B和B+数的区别为什么使用B+数, 15.MySQL有哪些锁, 16.Mysql内连接、左连接、右连接的区别, 17.sql执行顺序, 18.如何设计数据库？, 19.where和having的区别？, 20.三大范式, 21.char和varchar的区别, 22.InnoDB 什么情况下会产生死锁, 23.MySQL 删除自增 id随后重启 MySQL 服务再插入数据自增 id 会从几开始？, 24.MySQL插入百万级的数据如何优化？, 五.常用开发框架系列, 1.什么是Spring？, 2.IOC是什么？, 3.AOP是什么？, 4.如何定义一个全局异常处理类？, 5.如何使用aop自定义日志？, 6.循环依赖是什么怎么解决的？, 7.Bean 的作用域, 8.Bean 生命周期, 9.Spring 事务原理？, 10.spring事务失效场景, 11.spring事务的隔离级别, 12.spring事务的传播行为, 13.Spring IoC, 12.spring用了哪些设计模式, 14.SpringMV工作原理, 15.springboot自动配置原理, 16 .springboot常用注解, 17.spring的bean是线程安全的吗？, 18.springcloud主要解决什么问题？, 19.CAP理论, 20.为什么不能同时保证一致性和可用性呢？, 21.熔断限流的理解？, 22.常用限流算法, , 六.Redis系列, 1.redis为什么快？, 2.redis持久化机制, 3.Redis如何实现key的过期删除？, 4.Redis数据类型应用场景, 5.Redis缓存穿透如何解决？, 6.Redis如何解决缓存击穿？, 7.Redis如何解决缓存雪崩？, 8.Redis分布式锁的实现原理, 9.Redis集群方案, 10.Redis集群主从同步原理, 11.Redis缓存一致性解决方案, 12.Redis内存淘汰策略, 七.计算机网络系列, 1.TCPx2FIP模型, 2.浏览器输入地址后做了什么？, 3.TCP三次握手, 4.为什么TCP不能两次握手, 5.TCP四次挥手, 6.为什么要进入时间等待状态？, 7.TCP 滑动窗口, 8.TCP拥塞控制, 9.TCP超时重传, 10.TCP可靠传输的实现, 11.TCP报头有哪些信息, 12.状态码, 13.http与https的区别, 14.socket通信流程, 八.linux系列, 1.linux常用命令, 2.linux的io模型, 4.IO多路复用详解, 5.epoll的LT和ET模式什么是语言有哪些特点和有什么区别说说什么是跨平台性原理是什么什么是字节码采用字节码的好处是什么为什么说语言编译与解释并存有哪些数据类型自动类型转换强制类型转换看看这几行代码什么是自动拆箱封箱和有什么区别是否能作用在上的区别及作用用最有效率的方法计算乘以说说自增自减运算看下这几个代码运行结果向对象和向过程的区别面向对象有哪些特性重载和重写的区别访问修饰符以及不写默认时的区别关键字有什么作用抽象类和接口有什么区别三高并发并行与并发的区别什么是进程和线程进程系统进行资源分配调度的基本单位线程是进程的一个执行路径一个进程至少有一个线程同一一进程多个线程共享进程的资源操作系统分配资源是给进程的资源是给现成的比如启动函数就是启动了一个进程函数就是一个主线程说说线程有几种创建方式继承类重写方法调用实现接口重写方法实现接口重写方法为什么调用方法时会执行方法那怎么不直接调用方法执行方法会先创建一条线程由创建出来的新线程去执行的方法这才起到多线程的效果为什么我们不能直接调用方法也很清楚如果直接调用的方法那么方法还是运行在主线程中相当于顺序执行就起不到多线程的效果线程有哪些常用的调度方法类也提供了一个方法用于等待的方法如果一个线程执行了语句其含义是当前线程等待线程终止之后才从返回线程会暂时让出指定时间的执行权但是线程所拥有的监视器资源比如锁还是持有不让出的指定的睡眠时间到了后该函数会正常返回接着参与的调度获取到资源后就可以继续运行线程有几种状态什么是线程上下文切换使用多线程的目的是为了充分利用但是我们知道并发其实是一个来应付多个线程为了让用户感觉多个线程是在同时执行的资源的分配采用了时间片轮转也就是给每个线程分配一个时间片线程在时间片内占用执行任务当线程使用完时间片后就会处于就绪状态并让出让其他线程占用这就是上下文切换守护线程了解吗中的线程分为两类分别为线程守护线程和线程用户线程在启动时会调用函数函数所在的钱程就是一个用户线程其实在内部同时还启动了很多守护线程比如垃圾回收线程那么守护线程和用户线程有什么区别呢区别之一是当最后一个非守护线程束时会正常退出而不管当前是否存在守护线程也就是说守护线程是否结束并不影响退出换而言之只要有一个用户线程还没结束正常情况下就不会退出线程间有哪些通信方式和关键字关键字可以用来修饰字段成员变量就是告知程序任何对该变量的访问均需要从共享内存中获取而对它的改变必须同步刷新回共享内存它能保证所有线程对变量访问的可见性关键字可以修饰方法或者以同步块的形式来进行使用它主要确保多个线程在同一个时刻只能有一个线程处于方法或者同步块中它保证了线程对变量访问的可见性和排他性等待通知机制可以通过内置的等待通知机制实现一个线程修改一个对象的值而另一个线程感知到了变化然后进行相应的操作管道输入输出流管道输入输出流和普通的文件输入输出流或者网络输入输出流不同之处在于它主要用于线程之间的数据传输而传输的媒介为内存使用如果一个线程执行了语句其含义是当前线程等待线程终止之后才从返回线程除了提供方法之外还提供了和两个具备超时特性的方法使用即线程变量是一个以对象为键任意对象为值的存储结构这个结构被附带在线程上也就是说一个线程可以根据一个对象查询到绑定在这个线程上的一个值可以通过方法来设置一个值在当前线程下再通过方法获取到原先设置的值是什么也就是线程本地变量如果你创建了一个变量那么访问这个变量的每个线程都会有这个变量的一个本地拷贝多个线程操作这个变量的时候实际是操作自己本地内存里面的变量从而起到线程隔离的作用避免了线程安全问题一基础篇接口和抽象类的区别相似点接口和抽象类都不能被实例化实现接口或继承抽象类的普通子类都必须实现这些抽象方法不同点抽象类可以包含普通方法和代码块接口里只能包含抽象方法静态方法和默认方法抽象类可以有构造方法而接口没有抽象类中的成员变量可以是各种类型的接口的成员变量只能是类型的并且必须赋值重载和重写的区别重载发生在同一个类中方法名相同参数列表返回类型权限修饰符可以不同重写发生在子类中方法名相参数列表返回类型都相同权限修饰符要大于父类方法声明异常范围要小于父类方法但是和修饰的方法不可重写和的区别比较基本类型比较的是值比较引用类型比较的是内存地址是类的方法本质上与一样但是有些类重写了方法比如的被重写后比较的是字符值另外重写了后也必须重写方法异常处理机制使用捕获异常中的代码一定会执行捕获异常后程序会继续执行使用声明该方法可能会抛出的异常类型出现异常后程序终止原理在以后是基于数组链表红黑树来实现的特点是不能重复可以为线程不安全的扩容机制的默认容量为默认的负载因子为当中元素个数超过容量乘以负载因子的个数时就创建一个大小为前一次两倍的新数组再将原来数组中的数据复制到新数组中当数组长度到达且链表长度大于时链表转为红黑树存取原理计算的值然后进行二次根据二次结果找到对应的索引位置如果这个位置有值先进性比较若结果为则取代该元素若结果为就使用高低位平移法将节点插入链表以前使用头插法但是头插法在并发扩容时可能会造成环形链表或数据丢失而高低位平移发会发生数据覆盖的情况想要线程安全的怎么办使用使用方法原如何保证的线程安全使用分段锁将一个分为了个段每个段都是一个小的每次操作只对其中一个段加锁采用保证线程安全每次插入数据时判断在当前数组下标是否是第一次插入是就通过方式插入然后判断是否是的话就说明其他线程正在进行扩容当前线程也会参与扩容删除方法用了修饰保证并发下移除元素安全与的区别的每个方法都用修饰因此是线程安全的但同时读写效率很低的不允许为只对进行一次进行了两次底层使用的数组加链表和的区别的底层使用动态数组默认容量为当元素数量到达容量时生成一个新的数组大小为前一次的倍然后将原来的数组过来因为数组在内存中是连续的地址所以查找数据更快由于扩容机制添加数据效率更低的底层使用链表在内存中是离散的没有扩容机制在查找数据时需要从头遍历所以查找慢但是添加数据效率更高如何保证的线程安全使用方法为加锁使用底层与相同但是每个方法都由修饰速度很慢使用下的该类实现了读操作不加锁写操作时为创建一个副本期间其它线程读取的都是原本写操作都在副本中进行写入完成后再将指针指向副本的区别由数组构成使用了修饰对进行改变时每次都会新生成一个对象然后把指针指向新的引用对象可变并且线程安全可变但线程不安全操作少量字符数据用单线程操作大量数据用多线程操作大量数据用和和都是类的方法默认是通过地址来计算码但是可能被重写过用内容来计算码默认通过地址判断两个对象是否相等但是可能被重写用内容来比较两个对象所以两个对象相等他们的和一定相等但是相等的两个对象未必相等如果重写必须重写比如在中如果是类型如果只重写了而没有重写的话则两个比较为的因为不同导致两个没有出现在一个索引上就会出现中存在两个相同的面向对象和面向过程的区别面向对象有封装继承多态性的特性所以相比面向过程易维护易复用易扩展但是因为类调用时要实例化所以开销大性能比面向过程低深拷贝和浅拷贝浅拷贝浅拷贝只复制某个对象的引用而不复制对象本身新旧对象还是共享同一块内存深拷贝深拷贝会创造一个一摸一样的对象新对象和原对象不共享内存修改新对象不会改变原对对象多态的作用多态的实现要有继承重写父类引用指向子类对象它的好处是可以消除类型之间的耦合关系增加类的可扩充性和灵活性什么是反射反射是通过获取类的对象然后动态的获取到这个类的内部结构动态的去操作类的属性和方法应用场景有要操作权限不够的类属性和方法时实现自定义注解时动态加载第三方包时按需加载类节省编译和初始化时间获取对象的方法有类路径类对象的创建对象得五种方式关键字方法反序列化二多线程篇进程和线程的区别进程间如何通信进程系统运行的基本单位进程在运行过程中都是相互独立但是线程之间运行可以相互影响线程独立运行的最小单位一个进程包含多个线程且它们共享同一进程内的系统资源进程间通过管道共享内存信号量机制消息队列通信什么是线程上下文切换当一个线程被剥夺使用权时切换到另外一个线程执行什么是死锁死锁指多个线程在执行过程中因争夺资源造成的一种相互等待的僵局死锁的必要条件互斥条件同一资源同时只能由一个线程读取不可抢占条件不能强行剥夺线程占有的资源请求和保持条件请求其他资源的同时对自己手中的资源保持不放循环等待条件在相互等待资源的过程中形成一个闭环想要预防死锁只需要破坏其中一个条件即可比如使用定时锁尽量让线程用相同的加锁顺序还可以用银行家算法可以预防死锁和的区别是关键字是一个类在发生异常时会自动释放锁需要手动释放锁是可重入锁非公平锁不可中断锁的是可重入锁可中断锁可以是公平锁也可以是非公平锁是层次通过监视器实现的是通过实现的什么是锁是一个抽象类可以用来构造锁和同步类如的原理是内部有三个核心组件一个是代表加锁状态初始值为一个是获取到锁的线程还有一个阻塞队列当有线程想获取锁时会以的形式将变为成功后便将加锁线程设为自己当其他线程来竞争锁时会判断是不是不是再判断加锁线程是不是自己不是的话就把自己放入阻塞队列这个阻塞队列是用双向链表实现的可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己是的话释放锁的时候就将当减到的时候就去唤醒阻塞队列的第一个线程为什么使用的双向链表因为有一些线程可能发生中断而发生中断时候就需要在同步阻塞队列中删除掉这个时候用双向链表方便删除掉中间的节点有哪些常见的锁分为独占锁和共享锁独占锁可重入可中断可以是公平锁也可以是非公平锁非公平锁就是会通过两次去抢占锁公平锁会按队列顺序排队信号量设定一个信号量当调用时判断是否还有信号有就获取一个信号量没有就阻塞等待其他线程释放信号量当调用时释放一个信号量唤醒阻塞线程应用场景允许多个线程访问某个临界资源时如上下车买卖票倒计数器给计数器设置一个初始值当调用时计数器减一当调用时判断计数器是否归不为就阻塞直到计数器为应用场景启动一个服务时主线程需要等待多个组件加载完毕之后再继续执行循环栅栏给计数器设置一个目标值当调用时会计数并判断计数器是否达到目标值未达到就阻塞直到计数器达到目标值应用场景多线程计算数据最后合并计算结果的应用场景和的区别是的方法是类的方法会释放锁不会释放锁要在同步方法或者同步代码块中执行没有限制要调用或唤醒自动唤醒和区别调用后线程进入就绪状态线程中调用线程的则执行完前进入阻塞状态线程池七大参数核心线程数线程池中的基本线程数量最大线程数当阻塞队列满了之后逐一启动最大线程的存活时间当阻塞队列的任务执行完后最大线长的回收时间最大线程的存活时间单位阻塞队列当核心线程满后后面来的任务都进入阻塞队列线程工厂用于生产线程任务拒绝策略阻塞队列满后拒绝任务有四种策略抛异常丢弃任务不抛异常打回任务尝试与最老的线程竞争内存模型内存模型屏蔽了各种硬件和操作系统的内存访问差异实现让程序在各平台下都能达到一致的内存访问效果它定义了如何将程序中的变量在主存中读取具体定义为所有变量都存在主存中主存是线程共享区域每个线程都有自己独有的工作内存线程想要操作变量必须从主从中变量到自己的工作区每个线程的工作内存是相互隔离的由于主存与工作内存之间有读写延迟且读写不是原子性操作所以会有线程安全问题保证并发安全的三大特性原子性一次或多次操作在执行期间不被其他线程影响可见性当一个线程在工作内存修改了变量其他线程能立刻知道有序性对指令的优化会让指令执行顺序改变有序性是禁止指令重排保证变量的可见性和有序性不保证原子性使用了修饰变量后在变量修改后会立即同步到主存中每次用这个变量前会从主存刷新单例模式双重校验锁变量为什么使用修饰禁止指令重排序分为三个步骤为实例对象分配内存用构造器初始化成员变量将实例对象引用指向分配的内存实例对象在分配内存后实才不为如果分配内存后还未初始化就先将实例对象指向了内存那么此时最外层的会判断实例对象已经不等于就直接将实例对象返回而此时初始化还没有完成线程使用方式继承类实现接口实现接口带有返回值线程池创建线程原理原理是为每个线程创建变量副本不同线程之间不可见保证线程安全每个线程内部都维护了一个为实例为要保存的副本但是使用会存在内存泄露问题因为为弱引用而为强引用每次时都会回收而不会被回收所以为了解决内存泄漏问题可以在每次使用完后删除或者使用修饰可以随时获取什么是锁锁可以保证原子性思想是更新内存时会判断内存值是否被别人修改过如果没有就直接更新如果被修改就重新获取值直到更新完成为止这样的缺点是只能支持一个变量的原子操作不能保证整个代码块的原子操作频繁失败导致开销大问题线程和线程同时去修改一个变量将值从改为但线程突然阻塞此时线程将改为然后线程又将改成此时线程将又改为这个过程线程是不知道的这就是问题可以通过版本号或时间戳解决锁原理和优化是通过对象头的来表明监视器的监视器本质是依赖操作系统的互斥锁实现的操作系统实现线程切换要从用户态切换为核心态成本很高此时这种锁叫重量级锁在以后引入了偏向锁轻量级锁重量级锁偏向锁当一段代码没有别的线程访问此时线程去访问会直接获取偏向锁轻量级锁当锁是偏向锁时有另外一个线程来访问会升级为轻量级锁线程会通过方式获取锁不会阻塞提高性能重量级锁轻量级锁自旋一段时间后线程还没有获取到锁会升级为重量级锁重量级锁时来竞争锁的所有线程都会阻塞性能降低注意锁只能升级不能降级如何根据核心数设计线程池线程数量密集型线程中十分消耗的线程数密集型线程数量的使用场景是一个提供原子操作的类使用实来现线程安全的数值操作因为禁止了的排序优化所以它不适合在并发量小的时候使用只适合在一些高并发程序中使用三篇运行时数据区内存结构线程私有区虚拟机栈每次调用方法都会在虚拟机栈中产生一个栈帧每个栈帧中都有方法的参数局部变量方法出口等信息方法执行完毕后释放栈帧本地方法栈为修饰的本地方法提供的空间在中与虚拟机合二为一程序计数器保存指令执行的地址方便线程切回后能继续执行代码线程共享区堆内存进行垃圾回收的主要区域存放对象信息分为新生代和老年代内存比例为新生代的区内存不够时时发生老年代内存不够时发生方法区存放类信息静态变量常量运行时常量池等信息之前用持久代实现后用元空间实现元空间使用的是本地内存而非在内存结构中什么情况下会内存溢出堆内存溢出当对象一直创建而不被回收时加载的类越来越多时虚拟机栈的线程越来越多时栈溢出方法调用次数过多一般是递归不当造成有哪些垃圾回收算法标记清除算法标记不需要回收的对象然后清除没有标记的对象会造成许多内存碎片复制算法将内存分为两块只使用一块进行垃圾回收时先将存活的对象复制到另一块区域然后清空之前的区域用在新生代标记整理算法与标记清除算法类似但是在标记之后将存活对象向一端移动然后清除边界外的垃圾对象用在老年代如何判断对象可以被回收引用计数法已淘汰为每个对象添加引用计数器引用为时判定可以回收会有两个对象相互引用无法回收的问题可达性分析法从开始往下搜索搜索过的路径称为引用链若一个对象没有任何的引用链则判定可以回收有虚拟机栈中引用的对象方法区中静态变量引用的对象本地方法栈中引用的对象典型垃圾回收器以最小的停顿时间为目标只运行在老年代的垃圾回收器使用标记清除算法可以并发收集以后的默认垃圾回收器注重响应速度支持并发采用标记整理复制算法回收内存使用可达性分析法来判断对象是否可以被回收类加载器和双亲委派机制从父类加载器到子类加载器分别为加载路径为加载路径为加载路径为还有一个自定义类加载器当一个类加载器收到类加载请求时会先把这个请求交给父类加载器处理若父类加载器找不到该类再由自己去寻找该机制可以避免类被重复加载还可以避免系统级别的类被篡改中有哪些引用强引用的对象哪怕内存溢出也不会回收软引用只有内存不足时才会回收弱引用每次垃圾回收都会回收虚引用必须配合引用队列使用一般用于追踪垃圾回收动作类加载过程加载把字节码通过二进制的方式转化到方法区中的运行数据区连接验证验证字节码文件的正确性准备正式为类变量在方法区中分配内存并设置初始值类型的变量在编译时已经赋值了解析将常量池中的符号引用如类的全限定名解析为直接引用类在实际内存中的地址初始化执行类构造器不是常规的构造方法为静态变量赋初值并初始化静态代码块类初始化顺序父类静态代码块和静态成员变量子类静态代码块和静态成员变量父类代码块和普通成员变量父类构造方法子类代码块和普成员变量子类构造方法对象的创建过程检查类是否已被加载没有加载就先加载类为对象在堆中分配内存使用方式分配防止在为分配内存时执行当前地址的指针还没有来得及修改对象就拿来分配内存初始化将对象中的属性都分配值或设置对象头为属性赋值和执行构造方法对象头中有哪些信息对象头中有两部分一部分是存储对象运行时的数据如对象的分代年龄标记锁的状态获取到锁的线程等另外一部分是表明对象所属类如果是数组还有一个部分存放数组长度内存参数堆空间最大内存堆空间最小内存一般设置成跟堆空间最大内存一样的新生代的最大内存区与区的比例为默认为垃圾回收器名称指定垃圾回收器设置单个线程栈大小一般设堆空间为最大可用物理地址的百分之的回收机制和原理的目的实现内存的自动释放使用可达性分析法判断对象是否可回收采用了分代回收思想将堆分为新生代老年代新生代中采用复制算法老年代采用整理算法当新生代内存不足时会发生老年代不足时会发送四篇和的区别有三大特性分别是事务外键行级锁这些都是不支持的另外是聚簇索引是非聚簇索引不支持全文索引支持支持自增和模式的读写不支持的访问速度一般快差异在于的行锁会比较消耗性能还可能有回表的过程先去辅助索引中查询数据找到数据对应的之后再通过回表到聚簇索引树查找数据事务特性原子性一个事务内的操作统一成功或失败一致性事务前后的数据总量不变隔离性事务与事务之间相互不影响持久性事务一旦提交发生的改变不可逆事务靠什么保证原子性由日志保证他记录了需要回滚的日志信息回滚时撤销已执行的一致性由其他三大特性共同保证是事务的目的隔离性由保证持久性由日志和内存保证修改数据时内存和会记录操作宕机时可恢复事务的隔离级别在高并发情况下并发事务会产生脏读不可重复读幻读问题这时需要用隔离级别来控制读未提交允许一个事务读取另一个事务已提交的数据可能出现不可重复读幻读读提交只允许事务读取另一个事务没有提交的数据可能出现不可重复读幻读可重复读确保同一字段多次读取结果一致可能出现欢幻读可串行化所有事务逐次执行没有并发问日默认隔离级别为可重复读级别分为快照度和当前读并且通过间隙锁解决了幻读问题什么是快照读和当前读快照读读取的是当前数据的可见版本可能是会过期数据不加锁的就是快照都当前读读取的是数据的最新版本并且当前读返回的记录都会上锁保证其他事务不会并发修改这条记录如排他锁共享锁都是当前读是什么是多版本并发控制为每次事务生成一个新版本数据每个事务都由自己的版本从而不加锁就决绝读写冲突这种读叫做快照读只在读已提交和可重复读中生效实现原理由四个东西保证他们是日志记录了数据历史版本事务进行快照读时动态生成产生的视图记录了当前系统中活跃的事务控制哪个历史版本对当前事务可见隐藏字段最近修改记录的事务隐藏字段回滚指针配合指向数据的上一个版本有哪些索引主键索引一张表只能有一个主键索引主键索引列不能有空值和重复值唯一索引唯一索引不能有相同值但允许为空普通索引允许出现重复值组合索引对多个字段建立一个联合索引减少索引开销遵循最左匹配原则全文索引引擎支持通过建立倒排索引提升检索效率广泛用于搜索引擎聚簇索引和非聚簇索引的区别聚簇索引聚簇索引的叶子节点存放的是主键值和数据行辅助索引在聚簇索引上创建的其它索引的叶子节点存放的是主键值或指向数据行的指针优点根据索引可以直接获取值所以他获取数据更快对于主键的排序查找和范围查找效率更高缺点如果主键值很大的话辅助索引也会变得很大如果用作为主键数据存储会很稀疏修改主键或乱序插入会让数据行移动导致页分裂所以一般我们定义主键时尽量让主键值小并且定义为自增和不可修改非聚簇索引辅助索引叶子节点存放的是数据行地址先根据索引找到数据地址再根据地址去找数据他们都是数结构如何做慢优化可以查看执行计划分析数据的扫描类型索引是否生效常见的慢查询优化有尽量减少的数据列尽量使用覆盖索引查找时使用索引进行排序否则的话需要进行回表查询时同样要用索引避免使用到临时表分页查询时如果后面的数字太大可以使用子查询查出主键再主键后条数据就能走覆盖索引使用复杂查询时使用关联查询来代替子查询并且最好使用内连接使用函数时直接使用的话的效率最高或唯一索引或数字表中总记录数字段不会统计在写语句时条件要使用索引否则会锁会从行锁升级为表锁表中数据是否太大是不是要分库分表为什么要用内连接而不用外连接用外连接的话连接顺序是固定死的比如他必须先对左表进行全表扫描然后一条条到右表去匹配而内连接的话会自己根据查询优化器去判断用哪个表做驱动子查询的话同样也会对驱动表进行全表扫描所以尽量用小表做驱动表整个查询的过程客户端向服务器发送一条查询请求服务器首先检查查询缓存如果命中缓存则返回存储在缓存中的结果否则进入下一阶段服务器进行解析预处理再由优化器生成对应的执行计划根据执行计划调用存储引擎的来执行查询将结果返回给客户端同时缓存查询结果注意只有在之前才有查询缓存之后查询缓存被去掉了执行计划中有哪些字段我们想看一个的执行计划使用的语句是表中的字段包括扫描类型效率从底到高为全表扫描全索引扫描我们的需要的数据在索引中可以获取使用索引进行范围查找使用非唯一索引列进行了关联查询使用唯一索引进行关联查询使用唯一索引查询一行数据表中只有一行数据额外的如何查询额外信息常见的有在排序缓冲区中进行排序需要回表查询数据表示使用覆盖索引排序时使用了索引排序但如果是按照降序排序的话就会使用反向扫描索引查询时要建立一个临时表存放数据找到了多少行数据实际使用到的索引查询的优先级越大优先级越高子查询的一般会更大查询的类型是普通查询还是联合查询还是子查询常见类型有不包含子查询标记复杂查询中最外层的查询标记只后子查询者一行的数据是数哪张表的可能的当前查询语句可能用到的索引可能为如果用了索引但是为有可能是表数据太少认为全表扫描更快编号显示索引的哪一行被使用了哪些情况索引会失效条件中有除非所有查询条件都有索引否则失效查询用开头索引失效索引列参与计算索引失效违背最左匹配原则索引失效索引字段发生类型转换索引失效觉得全表扫描更快时数据少索引失效和数的区别为什么使用数二叉树索引字段有序极端情况会变成链表形式数树的高度不可控数控制了树的高度但是索引值和都分布在每个具体的节点当中若要进行范围查询要进行多次回溯开销大树非叶子节点只存储索引值叶子节点再存储索引具体数据从小到大用链表连接在一起范围查询可直接遍历不需要回溯有哪些锁基于粒度表级锁对整张表加锁粒度大并发小行级锁对行加锁粒度小并发大间隙锁间隙锁锁住表的一个区间间隙锁之间不会冲突只在可重复读下才生效解决了幻读基于属性共享锁又称读锁一个事务为表加了读锁其它事务只能加读锁不能加写锁排他锁又称写锁一个事务加写锁之后其他事务不能再加任何锁避免脏读问题内连接左连接右连接的区别内连接取量表交集部分左连接取左表全部右表匹部分右连接取右表全部坐表匹部分执行顺序如何设计数据库抽取实体如用户信息商品信息评论分析其中属性如用户信息姓名性别分析表与表之间的关联关系然后可以参考三大范式进行设计设计主键时主键要尽量小并且定义为自增和不可修改和的区别是约束声明是过滤声明早于执行并且不可以使用聚合函数可以三大范式第一范式每个列都不可以再拆分第二范式在第一范式的基础上非主键列完全依赖于主键而不能是依赖于主键的一部分第三范式在第二范式的基础上非主键列只依赖于主键不依赖于其他非主键和的区别是不可变的最大长度为是可变的字符串最大长度为什么情况下会产生死锁事务已经获取数据的写锁想要去获取数据的写锁然后事务获取了的写锁想要去获取的写锁相互等待形成死锁解决死锁的机制有两个等待直到超时发起死锁检测主动回滚一条事务死锁检测的原理是构建一个以事务为顶点锁为边的有向图判断有向图是否存在环存在即有死锁我们平时尽量减少事务操作的资源和隔离级别删除自增随后重启服务再插入数据自增会从几开始引擎前下次自增会取表中最大原理是最大会记录在内存中重启之后会重新读取表中最大的后仍从删除数据后算起原理是它将最大记录在里了自增的都从删除数据后算起原理是它将最大记录到数据文件里了插入百万级的数据如何优化一次插入多条数据可以减少写日志和日志的次数是有长度限制的但可以调整保证数据按照索引进行有序插入可以分表后多线程插入五常用开发框架系列什么是是个轻量级的框架通过达到松耦合的目的通过可以分离应用业务逻辑和系统服务进行内聚性的开发不过配置各种组件时比较繁琐所以后面才出选了的框架是什么是控制反转是一种思想把对象的创建和调用从程序员手中交由容器管理降低对象之间的依赖关系创建一个的方式有方式注解方式方式我们在对一个进行实例化后要对他的属性进行填充大多数我们都是使用直接的填充依赖注入的他是有限按照类型进行匹配是什么是面向切面编程可以将那些与业务不相关但是很多业务都要调用的代码抽取出来思想就是不侵入原有代码的情况下对功能进行增强是基于动态代理实现的动态代理是有两种一种是动态代理一种是动态代理动态代理是原理是利用反射来实现的需要调用反射包下的类的方法来返回代理对象这个方法中有三个参数分别是用于加载代理类的类加载器被代理类实现的接口的数组和一个用于增强方法的实现类动态代理原理是利用开源包来实现的是把被代理类的文件加载进来通过修改它的字节码生成子类来处理动态代理要求被代理类必须有实现的接口生成的动态代理类会和代理类实现同样的接口则生成的动态代理类会继承被代理类默认使用动态代理当被代理的类没有接口时就使用动态代理如何定义一个全局异常处理类想要定义一个全局异常处理类的话我们需要在这个类上添加注解然后定义一些用于捕捉不同异常类型的方法在这些方法上添加异常类型和注解方法参数是和异常类型然后将异常消息进行处理如果我们需要自定义异常的话就写一个自定义异常类该类需要继承一个异常接口类属性包括类型的连续错误码错误信息再根据需求写构造方法如何使用自定义日志第一步创建一个切面类把它添加到容器中并添加注解第二步在切面类中写一个通知方法在方法上添加通知注解并通过切入点表达式来表示要对哪些方法进行日志打印然后方法参数为第三步通过这个参数可以获取当前执行的方法名方法参数等信息这样就可以根据需求在方法进入或结束时打印日志循环依赖是什么怎么解决的循环依赖就是在创建实例的时候里面包含着属性实例所以这个时候就需要去创建实例而创建实例过程中也包含着实例这样实例还在创建的过程当中所以就导致和实例都创建不出来通过三级缓存来解决循环依赖一级缓存单例池缓存经过了已经初始化完毕的二级缓存半成品池缓存还未初始化完毕的三级缓存缓存的是获取的代理对象的表达式我们在创建的过程中先将放入三级缓存这时要创建要创建就直接去三级缓存中查找并且判断需不需要进行处理如果需要就在三级缓存中获取的代理对象不需要就取原始对象然后将取出的对象放入二级缓存中这个时候其他需要依赖对象的直接从二级缓存中去获取即可当初始化完成进入一级缓存后继续执行生命周期当完成了属性的注入后就可以放入一级缓存了之前默认会解决循环依赖在之后需要通过配置开启解决循环依赖的作用域一个容器只有一个每次调用都会生成一个新的对象每个请求都会创建一个自己的同一个共享一个实例整个只有一个一个只有一个生命周期实例化属性赋值初始化销毁在这四步的基础上面提供了一些拓展点自身的方法包括了本身调用的方法和通过配置文件中的和指定的方法级生命周期接口方法包括了和这些接口的方法容器级生命周期接口方法包括了和这两个接口实现一般称它们的实现类为后处理器工厂后处理器接口方法包括了等等非常有用的工厂后处理器接口的方法工厂后处理器也是容器级的在应用上下文装配配置文件之后立即调用事务原理事务有编程式和声明式我们一般使用声明式在某个方法上增加注解这个方法中的会统一成功或失败原理是当一个方法加上注解会基于这个类生成一个代理对象并将这个代理对象作为当使用这个中的方法时如果存在注解就会将事务自动提交设为然后执行方法执行过程没有异常则提交有异常则回滚事务失效场景事务方法所在的类没有加载到容器中事务方法不是类型同一类中一个没有添加事务的方法调用另外以一个添加事务的方法事务不生效事务默认只回滚运行时异常可以用属性设置业务自己捕获了异常事务会认为程序正常秩序事务的隔离级别默认级别使用数据库自定义的隔离级别其它四种隔离级别与一样事务的传播行为支持当前事务如果不存在则新启一个事务支持当前事务如果不存在则抛出异常支持当前事务如果不存在则以非事务方式执行不支持当前事务创建一个新事物不支持当前事务如果已存在事务就抛异常不支持当前事务始终以非事务方式执行用了哪些设计模式用了工厂模式用了动态代理模式用来模板方法模式中用来适配器模式里的监听器用了观察者模式工作原理工作过程围绕着前端控制器几个重要组件有处理器映射器处理器适配器试图解析器工作流程接收用户请求将请求发送给根据请求找到具体的和拦截器返回给调用执行具体的并将返回的返回给将传给解析后返回具体根据进行视图渲染返回给用户自动配置原理在包下存放了内置的自动配置类和文件这个文件中存放了这些配置类的全类名启动类注解下有三个关键注解表示启动类是一个自动配置类扫描启动类所在包下及子包的组件到容器中下面有个子注解会导入上面所说的自动配置类这些配置类会根据元注解的装配条件生效生效的类就会被实例化加载到容器中这些自动配置类还会通过文件里配置来进行属性设值常用注解修饰类该控制器会返回数据修饰类该控制器的请求路径修饰属性按照类型进行依赖注入修饰参数将路径值映射到参数上修饰方法该方法会返回数据需要使用提交方式修饰参数将数据封装到对应参数中将类注册到容器开启事务的是线程安全的吗的默认作用域是单例的单例的不是线程安全的但是开发中大部分的都是无状态的不具备存储功能比如他们不需要保证线程安全如果要保证线程安全可以将的作用域改为比如像另外还可以采用来解决线程安全问题为每个线程保存一个副本变量每个线程只操作自己的副本变量主要解决什么问题解决服务之间的通信容灾负载平衡冗余问题能方便服务集中管理常用组件有注册中心配置中心远程调用服务熔断网关理论一致性这里指的强一致性也就是数据更新完访问任何节点看到的数据完全一致可用性就是任何没有发生故障的服务必须在规定时间内返回合正确结果容灾性当网络不稳定时节点之间无法通信造成分区这时要保证系统可以继续正常服务提高容灾性的办法就是把数据分配到每一个节点当中所以是分布式系统必须实现的然后需要在和中取舍为什么不能同时保证一致性和可用性呢当网络发生故障时如果要保障数据一致性那么节点相互间就只能阻塞等待数据真正同步时再返回就违背可用性了如果要保证可用性节点要在有限时间内将结果返回无法等待其它节点的更新消息此时返回的数据可能就不是最新数据就违背了一致性了熔断限流的理解中用组件来进行降级熔断限流熔断是对于消费者来讲当对提供者请求时间过久时为了不影响性能就对链接进行熔断限流是对于提供者来讲为了防止某个消费者流量太大导致其它更重要的消费者请求无法及时处理限流可用通过拒绝服务服务降级消息队列延时处理限流算法来实现常用限流算法计数器算法使用的和过期机制实现漏桶算法一般使用消息队列来实现系统以恒定速度处理队列中的请求当队列满的时候开始拒绝请求令牌桶算法计数器算法和漏桶算法都无法解决突然的大并发令牌桶算法是预先往桶中放入一定数量然后用恒定速度放入直到桶满为止所有请求都必须拿到才能访问系统六系列为什么快完全基于内存操作数据结构简单对数据操作简单执行命令是单线程的避免了上下文切换带来的性能问题也不用考虑锁的问题采用了非阻塞的多路复用机制使用了单线程来处理并发的连接内部采用的自己实现的事件分离器其实不是完全多线程的在核心的网络模型中是多线程的用来处理并发连接但是数据的操作都是单线程坚持单线程是因为是的性能瓶颈是网络延迟而不是多线程对数据读取不会带来性能提升持久化机制快照持久化的默认持久化机制通过父进程一个子进程子进程将的数据快照写入一个临时文件等待持久化完毕后替换上一次的文件整个过程主进程不进行任何的操作持久化策略可以通过配置单位时间内执行多少次操作触发持久化所以的优点是保证性能最大化恢复速度数据较快缺点是可能会丢失两次持久化之间的数据追加持久化以日志形式记录每一次的写入和删除操作策略有每秒同步每次操作同步不同步优点是数据完整性高缺点是运行效率低恢复时间长如何实现的过期删除采用的定期过期惰性过期定期删除每隔一段时间从设置过期时间的集合中随机抽取一些检查是否过期如果已经过期做删除处理惰性删除在被访问的时候检查是否过期如果过期则删除数据类型应用场景可以用来缓存信息可以用命令实现自增或自减的计数器与一样可以保存信息可以用来做消息队列的是原子性操作能一定程度保证线程安全可以做去重比如一个用户只能参加一次活动可以做交集求共友有序的可以实现排行榜缓存穿透如何解决缓存穿透是指频繁请求客户端和缓存中都不存在的数据缓存永远不生效请求都到达了数据库解决方案在接口上做基础校验比如就拦截缓存空对象找不到的数据也缓存起来并设置过期时间可能会造成短期不一致布隆过滤器在客户端和缓存之间添加一个过滤器拦截掉一定不存在的数据请求如何解决缓存击穿缓存击穿是值一个非常热点在某一瞬间失效导致大量请求到达数据库解决方案设置热点数据永不过期给缓存重建的业务加上互斥锁缺点是性能低如何解决缓存雪崩缓存雪崩是值某一时间同时失效或宕机导致大量请求到达数据库解决方案搭建集群保证高可用进行数据预热给不同的设置随机的过期时间给缓存业务添加限流降级通过加锁或队列控制操作的线程数量给业务添加多级缓存分布式锁的实现原理原理是使用命令来实现但是会有一系列问题任务时常超过缓存时间锁自动释放可以使用看门狗解决加锁和释放锁的不是同一线程可以在中存入删除时进行验证但是要注意验证锁和删除锁也不是一个原子性操作可以用脚本使之成为原子性操作不可重入可以使用解决实现机制类似计数集群下主节点宕机导致锁丢失使用红锁解决集群方案主从模式个节点多个节点节点宕机自动变成主节点哨兵模式在主从集群基础上添加哨兵节点或哨兵集群用于监控节点健康状态通过投票机制选择成为主节点分片集群主从模式和哨兵模式解决了并发读的问题但没有解决并发写的问题因此有了分片集群分片集群有多个节点并且不同保存不同的数据之间通过相互监测健康状态客户端请求任意一个节点都会转发到正确节点因为每个都被映射到个插槽上集群的是根据的值与插槽绑定集群主从同步原理主从同步第一次是全量同步第一次请求节点会根据判断是否是第一次同步是的话会生成发送给后续为增量同步在发送期间会产生一个缓存区间记录发送期间产生的新的命令节点在加载完后会持续读取缓存区间中的数据缓存一致性解决方案缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序先删除缓存后更新数据库存在的问题是可能会数据不一致一般使用延时双删来解决即先删除缓存再更新数据库休眠秒后再次淘汰缓存第二次删除可能导致吞吐率降低可以考虑进行异步删除先更新数据库后删除缓存存在的问题是会可能会更新失败可以采用延时删除但由于读比写快发生这一情况概率较小但是无论哪种策略都可能存在删除失败的问题解决方案是用中间件订阅日志提取需要删除的然后另写一段非业务代码去获取并尝试删除若删除失败就把删除失败的发送到消息队列然后进行删除重试内存淘汰策略当内存不足时按设定好的策略进行淘汰策略有淘汰最久没使用的淘汰一段时间内最少使用的淘汰快要过期的七计算机网络系列模型浏览器输入地址后做了什么三次握手为什么不能两次握手假设是两次握手若客户端发起的连接请求阻塞在网络中会造成该报文的重传这时服务收到连接请求后会立刻进入连接状态当双方传输完数据结束连接后第一次阻塞的请求突然又到达了服务端此时服务端又进入连接状态而客户端不会响应服务端的连接确认报文四次挥手为什么要进入时间等待状态若客户端发送确认释放包后直接关闭而服务端因为某种原因没有收到客户端的确认释放包就会一直发送确认请求而客户端永远不会再响应该请求滑动窗口流量控制主要使用滑动窗口协议滑动窗口是接受数据端使用的窗口大小用来告诉发送端接收端的缓存大小以此可以控制发送端发送数据的大小从而达到流量控制的目的如果发送方收到接收方的零窗口通知后会启动持续计时器计时器超时后向接收方发送零窗口探测报文如果响应仍为就重新计时不为就打破死锁拥塞控制发送方会维护一个拥塞窗口大小的状态变量大小取决于网络的拥塞程度发送方的发送窗口大小是取接收方接收窗口和拥塞窗口中较小的一个拥塞控制有四种算法慢开始从小到大主键发送窗口每收到一个确认报文窗口大小指数增长拥塞避免当窗口大小到达一定阈值时转为拥塞避免每收到一个确认报文窗口大小若此时网络超时就把阈值调小一半重新慢开始快重传要求接收方收到请求后要立即回复快恢复发送方连续收到多个确认时就把拥塞避免阈值减小然后直接开始拥塞避免超时重传发送方在发送按数据后一定时间内没有收到接收方响应报文就会重新发送刚刚的报文接收到收到报文后会对该报文的序列号进行检验已存在就抛弃可靠传输的实现是靠滑动窗口协议和连续协议配合流量控制和拥塞控制来保证的可靠传输是停止等待协议和自动重传请求它规定要为每一次传输的包编号每发送一个包要等待对方确认后才能发送下一个分组若一段时间对方没有确认就重新发送刚刚的报文接收方会对数据包排序把有序数据传给应用层返回缺失的第一个确认序列号给发送方接收到收到报文后会对该报文的序列号进行检验重复就丢弃流量控制是拥塞窗口上上面已经说了报头有哪些信息状态码请求正在处理请求成功处理请求重定向永久重定向临时重定向使用本地缓存客户端错误请求格式错误没有访问权限请求体过大服务端错误与的区别通信流程服务端创建并调用方法绑定和端口号服务端调用方法建立监听此时服务的还没有打开客户端创建并调用方法像服务端请求连接服务端监听到客户端请求后被动打开调用方法接收客户端连接请求当方法接收到客户端方法返回的响应成功的信息后连接成功客户端向写入请求信息服务端读取信息客户端调用结束链接服务端监听到释放连接请求后也结束链接八系列常用命令查看网络接口详情查看与某主机是否能联通进程名称查看进程号端口查看端口占用情况查看系统负载情况包括系统时间系统所有进程状态情况查看内存占用情况正常杀死进程发出的信号可能会被阻塞强制杀死进程发送的是命令不会被阻塞的模型是对磁盘或网络数据的读写用户进程读取一次请求分为两个阶段等待数据到达内核缓冲区和将内核缓冲区数据拷贝到用户空间当用户去内核中拷贝数据时要从用户态转为核心态中模型同步阻塞模型用户进程发起调用后会被阻塞等待内核缓冲区数据准备完毕时就被唤醒将内核数据复制到用户进程这两个阶段都是阻塞的同步非阻塞模型用户进程发起调用后若内核缓冲区数据还未准备好进程会继续干别的事每隔一段时间就去看看内核数据是否准备好不过将内核数据复制到用户进程这个阶段依旧是阻塞的多路复用模型中把一切都看成文件每个文件都有一个文件描述符来关联多路复用模型就是复用单个进程同时监测多个文件描述符当某个文件描述符可读或可写就去通知用户进程信号模型用户进程发起调用后会向内核注册一个信号处理函数然后继续干别的事当内核数据准备就绪时就通知用户进程来进行拷贝异步非阻塞模型前面四种全是同步的进程在发起调用后会直接返回结果待内核数据准备好时由内核将数据复制给用户进程两个阶段都是非阻塞的多路复用详解中把一切都看成文件每个文件都有一个文件描述符来关联多路复用模型就是复用单个进程同时监测多个文件描述符当某个文件描述符可读或可写就去通知用户进程多路复用有三种方式采用数组结构监测的有限默认为当有文件描述符就绪时需要遍历整个数组来查看是哪个文件描述符就绪了效率较低每次调用时都需要把整个文件描述符数组从用户态拷贝到内核态中来回拷贝当很多时开销会很大采用链表结构监测的文件描述符没有上限其它的根差不多采用红黑树结构监测的没有上限它有三个方法用于创建一个实例实例中有一颗红黑树记录监测的一个链表记录就绪的用于往实例中增删要监测的文件描述符并设置回调函数当文件描述符就绪时触发回调函数将文件描述符添加到就绪链表当中用于见擦汗就绪列表并返回就绪列表的长度然后将就绪列表的拷贝到用户空间缓冲区中所以的优点是当有文件描述符就绪时只把已就绪的文件描述符写给用户空间不需要每次都遍历集合每个只有在调新增的时候和就绪的时候才会在用户空间和内核空间之间拷贝一次的和模式默认水平触发当有数据可读的时候那么每次都会去通知用户来操作直到读完边缘触发当有数据可读的时候它只会通知用户一次直到下次再有数据流入才会再通知所以在模式下一定要把缓冲区的数据一次读完").trim().substring(0, 1000);
    let value = Math.floor(Math.random() * 3) + 1000;
    while (value === prevParam || truncateDescription.length - value === prevParam) {
      value = Math.floor(Math.random() * 3) + 1000;
    }
    aiTitleRefreshIcon.style.opacity = "0.2";
    aiTitleRefreshIcon.style.transitionDuration = "0.3s";
    aiTitleRefreshIcon.style.transform = "rotate(" + 360 * refreshNum + "deg)";
    if (truncateDescription.length <= 1000) {
      let param = truncateDescription.length - Math.floor(Math.random() * 3);
      while (param === prevParam) {
        param = truncateDescription.length - Math.floor(Math.random() * 3);
      }
      aiAbstract(param);
      prevParam = param;
    } else {
      aiAbstract(value);
      prevParam = value;
    }
    showAiBtn();
    refreshNum++;
  });

  document.getElementById("go-tianli-blog").addEventListener("click", () => {
    window.open("https://afdian.net/item/886a79d4db6711eda42a52540025c377", "_blank");
  });
  
  if (false) {
    document.getElementById("ai-Toggle").addEventListener("click", () => {
      changeShowMode()
    });
  }

  function showAiBtn() {
    document.querySelectorAll(".ai-btn-item").forEach(item => {
      if (item.id !== "go-tianli-blog") {
        item.style.display = "block";
      }
      if (item.id === "go-tianli-blog") {
        item.style.display = "none";
      }
    });
  }


  aiAbstract();
  showAiBtn()
})()</script></div><article class="post-content" id="article-container"><p>9-24</p>
<p><strong>1.<strong>什么是</strong>Java</strong>？</p>
<p><strong>2.Java</strong>语言有哪些特点？</p>
<p><strong>3.JVM</strong>、<strong>JDK</strong> 和 <strong>JRE</strong> 有什么区别？</p>
<p><strong>4.<strong>说说什么是跨平台性？原理是什么</strong>?</strong></p>
<p><strong>5.<strong>什么是字节码？采用字节码的好处是什么</strong>?</strong></p>
<p><strong>6.<strong>为什么说 <strong>Java</strong> 语言</strong>“</strong>编译与解释并存<strong>”</strong>？</p>
<p><strong>7.Java</strong>有哪些数据类型？</p>
<p>**8.**自动类型转换、强制类型转换？看看这几行代码？</p>
<p>**9.<strong>什么是自动拆箱</strong>&#x2F;**封箱？</p>
<p>**10.&amp;<strong>和</strong>&amp;&amp;**有什么区别？</p>
<p><strong>11.switch</strong> 是否能作用在 <strong>byte&#x2F;long&#x2F;String</strong>上？</p>
<p><strong>12.break ,continue ,return</strong> 的区别及作用？</p>
<p><strong>13.<strong>用最有效率的方法计算</strong>2</strong>乘以<strong>8</strong>？</p>
<p><strong>14.<strong>说说</strong>自增自减</strong>运算？看下这几个代码运行结果？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">i = i++;</span><br><span class="line">System.out.println(i);</span><br><span class="line">//1</span><br></pre></td></tr></table></figure>

<p><strong>15.<strong>⾯向对象和⾯向过程的区别?</strong></strong></p>
<p><strong>16.<strong>面向对象有哪些特性</strong>?</strong></p>
<p><strong>17.<strong>重载（</strong>overload</strong>）和重写（<strong>override</strong>）的区别？</p>
<p><strong>18.<strong>访问修饰符</strong>public</strong>、<strong>private</strong>、<strong>protected</strong>、以及不写（默认）时的</p>
<p>区别？</p>
<p><strong>19.this</strong>关键字有什么作用？</p>
<p>**20.<strong>抽象类</strong>(abstract class)<strong>和接口</strong>(interface)**有什么区别？</p>
<h1 id="三、高并发"><a href="#三、高并发" class="headerlink" title="三、高并发"></a>三、高并发</h1><p>1.并行与并发的区别</p>
<p>2.什么是进程和线程</p>
<p>进程：系统进行资源分配调度的基本单位</p>
<p>线程：是进程的一个执行路径，一个进程至少有一个线程，同一一进程多个线程共享进程的资源</p>
<p>操作系统分配资源是给进程的，cpu资源是给现成的，比如启动main函数，就是启动了一个JVM进程，main函数就是一个主线程</p>
<p>**3.**说说线程有几种创建方式？</p>
<p> 继承Thread类，重写run方法，调用start（）</p>
<p>实现runnable接口，重写run方法</p>
<p>实现Callable接口，重写call方法</p>
<p>**4.<strong>为什么调用</strong>start()<strong>方法时会执行</strong>run()**方法，那怎么不直接调用</p>
<p>**run()**方法？</p>
<p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果</p>
<p>为什么我们不能直接调用**run()**方法？也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果</p>
<p>**5.**线程有哪些常用的调度方法？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021211209937.png" alt="image-20231021211209937"></p>
<p>Thread类也提供了一个方法用于等待的方法：</p>
<p>​	join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</p>
<p>sleep(long millis) :线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</p>
<p>**6.**线程有几种状态？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021213135931.png" alt="image-20231021213135931"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021213213839.png" alt="image-20231021213213839"></p>
<p>**7.**什么是线程上下文切换？</p>
<p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021213402650.png" alt="image-20231021213402650"></p>
<p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p>
<p>**8.**守护线程了解吗？</p>
<p>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</p>
<p>在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时，</p>
<p>JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出</p>
<p>**9.**线程间有哪些通信方式？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/blog/image-20231021215725184.png" alt="image-20231021215725184"></p>
<p><strong>volatile和synchronized关键字</strong></p>
<p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
<p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性</p>
<p><strong>等待&#x2F;通知机制</strong></p>
<p>可以通过Java内置的等待&#x2F;通知机制（wait()&#x2F;notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</p>
<p><strong>管道输入&#x2F;输出流</strong></p>
<p>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p><strong>使用Thread.join()</strong></p>
<p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p>
<p><strong>使用ThreadLocal</strong></p>
<p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p>
<p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
<p><strong>10.ThreadLocal</strong>是什么？</p>
<p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p>
<h3 id="一、JAVA基础篇"><a href="#一、JAVA基础篇" class="headerlink" title="一、JAVA基础篇"></a>一、JAVA基础篇</h3><h4 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1.接口和抽象类的区别"></a>1.接口和抽象类的区别</h4><p>相似点：</p>
<p>（1）接口和抽象类都不能被实例化</p>
<p>（2）实现接口或继承抽象类的普通子类都必须实现这些抽象方法</p>
<p>不同点：</p>
<p>（1）抽象类可以包含普通方法和代码块，接口里只能包含抽象方法，静态方法和默认方法，</p>
<p>（2）抽象类可以有构造方法，而接口没有</p>
<p>（3）抽象类中的成员变量可以是各种类型的，接口的成员变量只能是 <strong>public static final</strong> 类型的，并且必须赋值</p>
<h4 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h4><p>重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同</p>
<p>重写发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写</p>
<h4 id="3-和equals的区别"><a href="#3-和equals的区别" class="headerlink" title="3.&#x3D;&#x3D;和equals的区别"></a>3.&#x3D;&#x3D;和equals的区别</h4><p>&#x3D;&#x3D;比较基本类型，比较的是值，&#x3D;&#x3D;比较引用类型，比较的是内存地址</p>
<p>equlas是Object类的方法，本质上与&#x3D;&#x3D;一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是字符值，另外重写了equlas后，也必须重写hashcode()方法</p>
<h4 id="4-异常处理机制"><a href="#4-异常处理机制" class="headerlink" title="4.异常处理机制"></a>4.异常处理机制</h4><p>（1）使用try、catch、finaly捕获异常，finaly中的代码一定会执行，捕获异常后程序会继续执行</p>
<p>（2）使用throws声明该方法可能会抛出的异常类型，出现异常后，程序终止</p>
<h4 id="5-HashMap原理"><a href="#5-HashMap原理" class="headerlink" title="5.HashMap原理"></a>5.HashMap原理</h4><p>1.HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全</p>
<p>2.HashMap的扩容机制：</p>
<p>HashMap的默认容量为16，默认的负载因子为0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树</p>
<p>3.HashMap存取原理：</p>
<p>（1）计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置</p>
<p>（2）如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）</p>
<h4 id="6-想要线程安全的HashMap怎么办？"><a href="#6-想要线程安全的HashMap怎么办？" class="headerlink" title="6.想要线程安全的HashMap怎么办？"></a>6.想要线程安全的HashMap怎么办？</h4><p>（1）使用ConcurrentHashMap</p>
<p>（2）使用HashTable</p>
<p>（3）Collections.synchronizedHashMap()方法</p>
<h4 id="7-ConcurrentHashMap原如何保证的线程安全？"><a href="#7-ConcurrentHashMap原如何保证的线程安全？" class="headerlink" title="7.ConcurrentHashMap原如何保证的线程安全？"></a>7.ConcurrentHashMap原如何保证的线程安全？</h4><p>JDK1.7:使用分段锁，将一个Map分为了16个段，每个段都是一个小的hashmap，每次操作只对其中一个段加锁</p>
<p>JDK1.8:采用CAS+Synchronized保证线程安全，每次插入数据时判断在当前数组下标是否是第一次插入，是就通过CAS方式插入，然后判断f.hash是否&#x3D;-1，是的话就说明其他线程正在进行扩容，当前线程也会参与扩容；删除方法用了synchronized修饰，保证并发下移除元素安全</p>
<h4 id="8-HashTable与HashMap的区别"><a href="#8-HashTable与HashMap的区别" class="headerlink" title="8.HashTable与HashMap的区别"></a>8.HashTable与HashMap的区别</h4><p>（1）HashTable的每个方法都用synchronized修饰，因此是线程安全的，但同时读写效率很低</p>
<p>（2）HashTable的Key不允许为null</p>
<p>（3）HashTable只对key进行一次hash，HashMap进行了两次Hash</p>
<p>（4）HashTable底层使用的数组加链表</p>
<h4 id="9-ArrayList和LinkedList的区别"><a href="#9-ArrayList和LinkedList的区别" class="headerlink" title="9.ArrayList和LinkedList的区别"></a>9.ArrayList和LinkedList的区别</h4><p> ArratList的底层使用动态数组，默认容量为10，当元素数量到达容量时，生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来；因为数组在内存中是连续的地址，所以ArrayList查找数据更快，由于扩容机制添加数据效率更低</p>
<p>LinkedList的底层使用链表，在内存中是离散的，没有扩容机制；LinkedList在查找数据时需要从头遍历，所以查找慢，但是添加数据效率更高</p>
<h4 id="10-如何保证ArrayList的线程安全？"><a href="#10-如何保证ArrayList的线程安全？" class="headerlink" title="10.如何保证ArrayList的线程安全？"></a>10.如何保证ArrayList的线程安全？</h4><p>（1）使用collentions.synchronizedList（）方法为ArrayList加锁</p>
<p>（2）使用Vector，Vector底层与Arraylist相同，但是每个方法都由synchronized修饰，速度很慢</p>
<p>（3）使用juc下的CopyOnWriterArrayList，该类实现了读操作不加锁，写操作时为list创建一个副本，期间其它线程读取的都是原本list，写操作都在副本中进行，写入完成后，再将指针指向副本。</p>
<h4 id="11-String、StringBuffer、StringBuilder的区别"><a href="#11-String、StringBuffer、StringBuilder的区别" class="headerlink" title="11.String、StringBuffer、StringBuilder的区别"></a>11.String、StringBuffer、StringBuilder的区别</h4><p>String 由 char[] 数组构成，使用了 final 修饰，对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象。</p>
<p>StringBuffer可变并且线程安全</p>
<p>StringBuiler可变但线程不安全。</p>
<p>操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。</p>
<h4 id="12-hashCode和equals"><a href="#12-hashCode和equals" class="headerlink" title="12.hashCode和equals"></a><strong>12.hashCode和equals</strong></h4><p> hashCode()和equals()都是Obkect类的方法，hashCode()默认是通过地址来计算hash码，但是可能被重写过用内容来计算hash码，equals()默认通过地址判断两个对象是否相等，但是可能被重写用内容来比较两个对象</p>
<p>所以两个对象相等，他们的hashCode和equals一定相等，但是hashCode相等的两个对象未必相等</p>
<p>如果重写equals()必须重写hashCode()，比如在HashMap中，key如果是String类型，String如果只重写了equals（）而没有重写hashcode（）的话，则两个equals()比较为true的key，因为hashcode不同导致两个key没有出现在一个索引上，就会出现map中存在两个相同的key</p>
<h4 id="13-面向对象和面向过程的区别"><a href="#13-面向对象和面向过程的区别" class="headerlink" title="13.面向对象和面向过程的区别"></a>13.面向对象和面向过程的区别</h4><p>面向对象有封装、继承、多态性的特性，所以相比面向过程易维护、易复用、易扩展，但是因为类调用时要实例化，所以开销大性能比面向过程低</p>
<h4 id="4-深拷贝和浅拷贝"><a href="#4-深拷贝和浅拷贝" class="headerlink" title="4.深拷贝和浅拷贝"></a>4.深拷贝和浅拷贝</h4><p>浅拷贝:浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存<br>深拷贝:深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。</p>
<h4 id="15-多态的作用"><a href="#15-多态的作用" class="headerlink" title="15.多态的作用"></a>15.多态的作用</h4><p>多态的实现要有继承、重写，父类引用指向子类对象。它的好处是可以消除类型之间的耦合关系，增加类的可扩充性和灵活性。</p>
<h4 id="16-什么是反射？"><a href="#16-什么是反射？" class="headerlink" title="16.什么是反射？"></a>16.什么是反射？</h4><p>反射是通过获取类的class对象，然后动态的获取到这个类的内部结构，动态的去操作类的属性和方法。<br>应用场景有：要操作权限不够的类属性和方法时、实现自定义注解时、动态加载第三方jar包时、按需加载类，节省编译和初始化时间；<br>获取class对象的方法有：class.forName(类路径)，类.class()，对象的getClass（）</p>
<h4 id="17-Java创建对象得五种方式"><a href="#17-Java创建对象得五种方式" class="headerlink" title="17.Java创建对象得五种方式?"></a>17.Java创建对象得五种方式?</h4><p>(1)new关键字  (2)Class.newInstance (3)Constructor.newInstance</p>
<p>(4)Clone方法  (5)反序列化</p>
<h3 id="二-Java多线程篇"><a href="#二-Java多线程篇" class="headerlink" title="二.Java多线程篇"></a>二.Java多线程篇</h3><h4 id="1-进程和线程的区别，进程间如何通信"><a href="#1-进程和线程的区别，进程间如何通信" class="headerlink" title="1.进程和线程的区别，进程间如何通信"></a>1.进程和线程的区别，进程间如何通信</h4><p>进程：系统运行的基本单位，进程在运行过程中都是相互独立，但是线程之间运行可以相互影响。</p>
<p>线程：独立运行的最小单位，一个进程包含多个线程且它们共享同一进程内的系统资源</p>
<p>进程间通过管道、 共享内存、信号量机制、消息队列通信</p>
<h4 id="2-什么是线程上下文切换"><a href="#2-什么是线程上下文切换" class="headerlink" title="2. 什么是线程上下文切换"></a>2. 什么是线程上下文切换</h4><p>当一个线程被剥夺cpu使用权时，切换到另外一个线程执行</p>
<h4 id="3-什么是死锁"><a href="#3-什么是死锁" class="headerlink" title="3.什么是死锁"></a>3.什么是死锁</h4><p>死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局</p>
<h4 id="4-死锁的必要条件"><a href="#4-死锁的必要条件" class="headerlink" title="4.死锁的必要条件"></a>4.死锁的必要条件</h4><p>互斥条件：同一资源同时只能由一个线程读取</p>
<p>不可抢占条件：不能强行剥夺线程占有的资源</p>
<p>请求和保持条件：请求其他资源的同时对自己手中的资源保持不放</p>
<p>循环等待条件：在相互等待资源的过程中，形成一个闭环</p>
<p>想要预防死锁，只需要破坏其中一个条件即可，比如使用定时锁、尽量让线程用相同的加锁顺序，还可以用银行家算法可以预防死锁 </p>
<h4 id="5-Synchrpnized和lock的区别"><a href="#5-Synchrpnized和lock的区别" class="headerlink" title="5.Synchrpnized和lock的区别"></a>5.Synchrpnized和lock的区别</h4><p>（1）synchronized是关键字，lock是一个类</p>
<p>（2） synchronized在发生异常时会自动释放锁，lock需要手动释放锁</p>
<p>（3）synchronized是可重入锁、非公平锁、不可中断锁，lock的ReentrantLock是可重入锁，可中断锁，可以是公平锁也可以是非公平锁</p>
<p>（4）synchronized是JVM层次通过监视器实现的，Lock是通过AQS实现的</p>
<h4 id="6-什么是AQS锁"><a href="#6-什么是AQS锁" class="headerlink" title="6.什么是AQS锁?"></a>6.什么是AQS锁?</h4><p>AQS是一个抽象类，可以用来构造锁和同步类，如ReentrantLock，Semaphore，CountDownLatch，CyclicBarrier。</p>
<p>AQS的原理是，AQS内部有三个核心组件，一个是state代表加锁状态初始值为0，一个是获取到锁的线程，还有一个阻塞队列。当有线程想获取锁时，会以CAS的形式将state变为1，CAS成功后便将加锁线程设为自己。当其他线程来竞争锁时会判断state是不是0，不是0再判断加锁线程是不是自己，不是的话就把自己放入阻塞队列。这个阻塞队列是用双向链表实现的</p>
<p>可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。</p>
<p><strong>7.为什么AQS使用的双向链表？</strong></p>
<p>因为有一些线程可能发生中断 ，而发生中断时候就需要在同步阻塞队列中删除掉，这个时候用双向链表方便删除掉中间的节点</p>
<h4 id="8-有哪些常见的AQS锁"><a href="#8-有哪些常见的AQS锁" class="headerlink" title="8.有哪些常见的AQS锁"></a>8.有哪些常见的AQS锁</h4><p>AQS分为独占锁和共享锁</p>
<p><strong>ReentrantLock（独占锁）</strong>：可重入，可中断，可以是公平锁也可以是非公平锁，非公平锁就是会通过两次CAS去抢占锁，公平锁会按队列顺序排队</p>
<p><strong>Semaphore（信号量）</strong>:设定一个信号量，当调用acquire()时判断是否还有信号，有就获取一个信号量，没有就阻塞等待其他线程释放信号量，当调用release()时释放一个信号量，唤醒阻塞线程。</p>
<p>应用场景：允许多个线程访问某个临界资源时，如上下车，买卖票</p>
<p><strong>CountDownLatch（倒计数器）</strong>:给计数器设置一个初始值，当调用CountDown()时计数器减一，当调用await() 时判断计数器是否归0，不为0就阻塞，直到计数器为0。</p>
<p>应用场景：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行</p>
<p><strong>CyclicBarrier（循环栅栏）</strong>:给计数器设置一个目标值,当调用await() 时会计数+1并判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值</p>
<p>应用场景：多线程计算数据，最后合并计算结果的应用场景</p>
<p><strong>9.sleep()和wait()的区别</strong></p>
<p> (1)wait()是Object的方法，sleep()是Thread类的方法</p>
<p>(2)wait()会释放锁，sleep()不会释放锁</p>
<p>(3)wait()要在同步方法或者同步代码块中执行，sleep()没有限制</p>
<p>(4)wait()要调用notify()或notifyall()唤醒,sleep()自动唤醒</p>
<h4 id="10-yield-和join-区别"><a href="#10-yield-和join-区别" class="headerlink" title="10.yield()和join()区别"></a>10.yield()和join()区别</h4><p>yield()调用后线程进入就绪状态</p>
<p>A线程中调用B线程的join() ,则B执行完前A进入阻塞状态</p>
<h4 id="11-线程池七大参数"><a href="#11-线程池七大参数" class="headerlink" title="11.线程池七大参数"></a>11.线程池七大参数</h4><p>核心线程数：线程池中的基本线程数量</p>
<p>最大线程数：当阻塞队列满了之后，逐一启动</p>
<p>最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间</p>
<p>最大线程的存活时间单位</p>
<p>阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列</p>
<p>线程工厂：用于生产线程</p>
<p>任务拒绝策略：阻塞队列满后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争</p>
<h4 id="12-Java内存模型"><a href="#12-Java内存模型" class="headerlink" title="12.Java内存模型"></a>12.Java内存模型</h4><p>JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取</p>
<p>具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的</p>
<p>由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题</p>
<h4 id="13-保证并发安全的三大特性？"><a href="#13-保证并发安全的三大特性？" class="headerlink" title="13.保证并发安全的三大特性？"></a>13.保证并发安全的三大特性？</h4><p> 原子性：一次或多次操作在执行期间不被其他线程影响</p>
<p>可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道</p>
<p>有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排</p>
<h4 id="14-volatile"><a href="#14-volatile" class="headerlink" title="14.volatile"></a>14.volatile</h4><p>保证变量的可见性和有序性，不保证原子性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。</p>
<p>单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：为实例对象分配内存，用构造器初始化成员变量，将实例对象引用指向分配的内存；实例对象在分配内存后实才不为null。如果分配内存后还未初始化就先将实例对象指向了内存，那么此时最外层的if会判断实例对象已经不等于null就直接将实例对象返回。而此时初始化还没有完成。</p>
<h4 id="15-线程使用方式"><a href="#15-线程使用方式" class="headerlink" title="15.线程使用方式"></a>15.线程使用方式</h4><p>(1)继承 Tread 类</p>
<p>(2)实现 Runnable 接口</p>
<p>(3)实现 Callable 接口：带有返回值</p>
<p>(4)线程池创建线程</p>
<h4 id="16-ThreadLocal原理"><a href="#16-ThreadLocal原理" class="headerlink" title="16.ThreadLocal原理"></a>16.ThreadLocal原理</h4><p>原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。<br>但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value</p>
<h4 id="17-什么是CAS锁"><a href="#17-什么是CAS锁" class="headerlink" title="17.什么是CAS锁"></a>17.什么是CAS锁</h4><p>CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是</p>
<p>（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作 </p>
<p>（2）CAS频繁失败导致CPU开销大</p>
<p>（3）ABS问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决</p>
<h4 id="18-Synchronized锁原理和优化"><a href="#18-Synchronized锁原理和优化" class="headerlink" title="18.Synchronized锁原理和优化"></a>18.Synchronized锁原理和优化</h4><p>Synchronize是通过对象头的markwordk来表明监视器的，监视器本质是依赖操作系统的互斥锁实现的。操作系统实现线程切换要从用户态切换为核心态，成本很高，此时这种锁叫重量级锁，在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁</p>
<p>偏向锁：当一段代码没有别的线程访问，此时线程去访问会直接获取偏向锁</p>
<p>轻量级锁：当锁是偏向锁时，有另外一个线程来访问，会升级为轻量级锁。线程会通过CAS方式获取锁，不会阻塞，提高性能，</p>
<p>重量级锁：轻量级锁自旋一段时间后线程还没有获取到锁，会升级为重量级锁，重量级锁时，来竞争锁的所有线程都会阻塞，性能降低</p>
<p>注意，锁只能升级不能降级</p>
<h4 id="19-如何根据-CPU-核心数设计线程池线程数量"><a href="#19-如何根据-CPU-核心数设计线程池线程数量" class="headerlink" title="19.如何根据 CPU 核心数设计线程池线程数量"></a>19.如何根据 CPU 核心数设计线程池线程数量</h4><p>IO 密集型：线程中十分消耗Io的线程数*2<br>CPU密集型： cpu线程数量</p>
<h4 id="20-AtomicInteger的使用场景"><a href="#20-AtomicInteger的使用场景" class="headerlink" title="20.AtomicInteger的使用场景"></a>20.AtomicInteger的使用场景</h4><p>AtomicInteger是一个提供原子操作的Integer类，使用CAS+volatile实来现线程安全的数值操作。</p>
<p>因为volatile禁止了jvm的排序优化,所以它不适合在并发量小的时候使用，只适合在一些高并发程序中使用</p>
<h3 id="三-JVM篇"><a href="#三-JVM篇" class="headerlink" title="三.JVM篇"></a>三.JVM篇</h3><h4 id="1-JVM运行时数据区（内存结构）"><a href="#1-JVM运行时数据区（内存结构）" class="headerlink" title="1.JVM运行时数据区（内存结构）"></a>1.JVM运行时数据区（内存结构）</h4><p>线程私有区：</p>
<p>（1）虚拟机栈：每次调用方法都会在虚拟机栈中产生一个栈帧，每个栈帧中都有方法的参数、局部变量、方法出口等信息，方法执行完毕后释放栈帧</p>
<p>（2）本地方法栈：为native修饰的本地方法提供的空间，在HotSpot中与虚拟机合二为一</p>
<p>（3）程序计数器：保存指令执行的地址，方便线程切回后能继续执行代码</p>
<p>线程共享区：</p>
<p>（4）堆内存：Jvm进行垃圾回收的主要区域，存放对象信息，分为新生代和老年代，内存比例为1：2，新生代的Eden区内存不够时时发生MinorGC,老年代内存不够时发生FullGC</p>
<p>（5）方法区：存放类信息、静态变量、常量、运行时常量池等信息。JDK1.8之前用持久代实现，JDK1.8后用元空间实现，元空间使用的是本地内存，而非在JVM内存结构中</p>
<h4 id="2-什么情况下会内存溢出？"><a href="#2-什么情况下会内存溢出？" class="headerlink" title="2.什么情况下会内存溢出？"></a>2.什么情况下会内存溢出？</h4><p>堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时</p>
<p>栈溢出：方法调用次数过多，一般是递归不当造成</p>
<h4 id="3-JVM有哪些垃圾回收算法？"><a href="#3-JVM有哪些垃圾回收算法？" class="headerlink" title="3.JVM有哪些垃圾回收算法？"></a>3.JVM有哪些垃圾回收算法？</h4><p>（1）标记清除算法： 标记不需要回收的对象，然后清除没有标记的对象，会造成许多内存碎片。<br>（2）复制算法： 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。用在新生代<br>（3）标记整理算法： 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。用在老年代</p>
<h4 id="4-GC如何判断对象可以被回收？"><a href="#4-GC如何判断对象可以被回收？" class="headerlink" title="4.GC如何判断对象可以被回收？"></a><strong>4.GC如何判断对象可以被回收？</strong></h4><p>（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题</p>
<p>（2）可达性分析法：从GCRoot开始往下搜索，搜索过的路径称为引用链，若一个对象GCRoot没有任何的引用链，则判定可以回收</p>
<p> GCRoot有：虚拟机栈中引用的对象，方法区中静态变量引用的对象，本地方法栈中引用的对象</p>
<h4 id="5-典型垃圾回收器"><a href="#5-典型垃圾回收器" class="headerlink" title="5.典型垃圾回收器"></a>5.典型垃圾回收器</h4><p>CMS:以最小的停顿时间为目标、只运行在老年代的垃圾回收器，使用标记-清除算法，可以并发收集。</p>
<p>G1 ：JDK1.9以后的默认垃圾回收器，注重响应速度，支持并发，采用标记整理+复制算法回收内存，使用可达性分析法来判断对象是否可以被回收。</p>
<h4 id="6-类加载器和双亲委派机制"><a href="#6-类加载器和双亲委派机制" class="headerlink" title="6.类加载器和双亲委派机制"></a>6.类加载器和双亲委派机制</h4><p>从父类加载器到子类加载器分别为：</p>
<p>BootStrapClassLoader  加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib</p>
<p>ExtensionClassLoader  加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p>
<p>ApplicationClassLoader 加载路径为：classpath</p>
<p>还有一个自定义类加载器</p>
<p>当一个类加载器收到类加载请求时，会先把这个请求交给父类加载器处理，若父类加载器找不到该类，再由自己去寻找。该机制可以避免类被重复加载，还可以避免系统级别的类被篡改</p>
<h4 id="7-JVM中有哪些引用？"><a href="#7-JVM中有哪些引用？" class="headerlink" title="7.JVM中有哪些引用？"></a>7.JVM中有哪些引用？</h4><p>强引用：new的对象。哪怕内存溢出也不会回收</p>
<p>软引用：只有内存不足时才会回收</p>
<p>弱引用：每次垃圾回收都会回收</p>
<p>虚引用：必须配合引用队列使用，一般用于追踪垃圾回收动作</p>
<h4 id="8-类加载过程"><a href="#8-类加载过程" class="headerlink" title="8.类加载过程"></a>8.类加载过程</h4><p>（1）加载 ：把字节码通过二进制的方式转化到方法区中的运行数据区</p>
<p>（2）连接：</p>
<p> 验证：验证字节码文件的正确性。</p>
<p> 准备：正式为类变量在方法区中分配内存，并设置初始值，final类型的变量在编译时已经赋值了</p>
<p> 解析：将常量池中的符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址） </p>
<p>（3）初始化 ：执行类构造器（不是常规的构造方法），为静态变量赋初值并初始化静态代码块。</p>
<h4 id="9-JVM类初始化顺序"><a href="#9-JVM类初始化顺序" class="headerlink" title="9.JVM类初始化顺序"></a>9.JVM类初始化顺序</h4><p>父类静态代码块和静态成员变量-&gt;子类静态代码块和静态成员变量-&gt;父类代码块和普通成员变量-&gt;父类构造方法-&gt;子类代码块和普成员变量-&gt;子类构造方法</p>
<h4 id="10-对象的创建过程"><a href="#10-对象的创建过程" class="headerlink" title="10..对象的创建过程"></a>10..对象的创建过程</h4><p>（1）检查类是否已被加载，没有加载就先加载类</p>
<p>（2）为对象在堆中分配内存，使用CAS方式分配，防止在为A分配内存时，执行当前地址的指针还没有来得及修改，对象B就拿来分配内存。</p>
<p>（3）初始化，将对象中的属性都分配0值或null</p>
<p>（4）设置对象头</p>
<p>（5）为属性赋值和执行构造方法</p>
<h4 id="11-对象头中有哪些信息"><a href="#11-对象头中有哪些信息" class="headerlink" title="11.对象头中有哪些信息"></a>11.对象头中有哪些信息</h4><p>对象头中有两部分，一部分是MarkWork,存储对象运行时的数据，如对象的hashcode、GC分代年龄、GC标记、锁的状态、获取到锁的线程ID等；另外一部分是表明对象所属类，如果是数组，还有一个部分存放数组长度</p>
<h4 id="12-JVM内存参数"><a href="#12-JVM内存参数" class="headerlink" title="12.JVM内存参数"></a>12.JVM内存参数</h4><p>-Xmx[]:堆空间最大内存</p>
<p>-Xms[]:堆空间最小内存，一般设置成跟堆空间最大内存一样的</p>
<p>-Xmn[]:新生代的最大内存</p>
<p>-xx:[survivorRatio&#x3D;3]:eden区与from+to区的比例为3：1，默认为4：1</p>
<p>-xx[use 垃圾回收器名称]：指定垃圾回收器</p>
<p>-xss:设置单个线程栈大小</p>
<p>一般设堆空间为最大可用物理地址的百分之80</p>
<h4 id="13-GC的回收机制和原理"><a href="#13-GC的回收机制和原理" class="headerlink" title="13.GC的回收机制和原理"></a>13.GC的回收机制和原理</h4><p>GC的目的实现内存的自动释放，使用可达性分析法判断对象是否可回收，采用了分代回收思想，<br>将堆分为新生代、老年代，新生代中采用复制算法，老年代采用整理算法，当新生代内存不足时会发生minorGC,老年代不足时会发送fullGC</p>
<h3 id="四-Mysql篇"><a href="#四-Mysql篇" class="headerlink" title="四.Mysql篇"></a>四.Mysql篇</h3><h4 id="1-MyIsAm和InnoDB的区别"><a href="#1-MyIsAm和InnoDB的区别" class="headerlink" title="1.MyIsAm和InnoDB的区别"></a>1.MyIsAm和InnoDB的区别</h4><p>InnoDB有三大特性，分别是事务、外键、行级锁，这些都是MyIsAm不支持的，</p>
<p>另外InnoDB是聚簇索引，MyIAm是非聚簇索引，</p>
<p>InnoDB不支持全文索引，MyIAm支持</p>
<p>InnoDB支持自增和MVCC模式的读写，MyIAm不支持</p>
<p>MyIsAM的访问速度一般InnoDB快，差异在于innodb的mvcc、行锁会比较消耗性能，还可能有回表的过程（先去辅助索引中查询数据，找到数据对应的key之后，再通过key回表到聚簇索引树查找数据）</p>
<h4 id="2-mysql事务特性"><a href="#2-mysql事务特性" class="headerlink" title="2.mysql事务特性"></a>2.mysql事务特性</h4><p>原子性：一个事务内的操作统一成功或失败</p>
<p>一致性：事务前后的数据总量不变</p>
<p>隔离性：事务与事务之间相互不影响</p>
<p>持久性：事务一旦提交发生的改变不可逆</p>
<h4 id="3-事务靠什么保证"><a href="#3-事务靠什么保证" class="headerlink" title="3.事务靠什么保证"></a>3.事务靠什么保证</h4><p>原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql</p>
<p>一致性：由其他三大特性共同保证，是事务的目的</p>
<p>隔离性：由MVCC保证</p>
<p>持久性：由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复</p>
<h4 id="4-事务的隔离级别"><a href="#4-事务的隔离级别" class="headerlink" title="4.事务的隔离级别"></a>4.事务的隔离级别</h4><p>在高并发情况下，并发事务会产生脏读、不可重复读、幻读问题，这时需要用隔离级别来控制</p>
<p>读未提交： 允许一个事务读取另一个事务已提交的数据，可能出现不可重复读，幻读。</p>
<p>读提交：  只允许事务读取另一个事务没有提交的数据可能出现不可重复读，幻读。</p>
<p>可重复读： 确保同一字段多次读取结果一致，可能出现欢幻读。</p>
<p>可串行化： 所有事务逐次执行，没有并发问日</p>
<p>Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过间隙锁解决了幻读问题。</p>
<h4 id="5-什么是快照读和当前读"><a href="#5-什么是快照读和当前读" class="headerlink" title="5.什么是快照读和当前读"></a>5.什么是快照读和当前读</h4><p>*快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照都</p>
<p>*当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读</p>
<h4 id="6-MVCC是什么"><a href="#6-MVCC是什么" class="headerlink" title="6.MVCC是什么"></a>6.MVCC是什么</h4><p>MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突，这种读叫做快照读。只在读已提交和可重复读中生效。</p>
<p>实现原理由四个东西保证，他们是</p>
<p>undolog日志：记录了数据历史版本</p>
<p>readView:事务进行快照读时动态生成产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见</p>
<p>隐藏字段DB_TRC_ID： 最近修改记录的事务ID </p>
<p>隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本</p>
<h4 id="7-MySQL有哪些索引"><a href="#7-MySQL有哪些索引" class="headerlink" title="7.MySQL有哪些索引"></a>7.MySQL有哪些索引</h4><p>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</p>
<p>唯一索引：唯一索引不能有相同值，但允许为空</p>
<p>普通索引：允许出现重复值</p>
<p>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</p>
<p>全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎</p>
<h4 id="8-聚簇索引和非聚簇索引的区别"><a href="#8-聚簇索引和非聚簇索引的区别" class="headerlink" title="8.聚簇索引和非聚簇索引的区别"></a>8.聚簇索引和非聚簇索引的区别</h4><p>聚簇索引：聚簇索引的叶子节点存放的是主键值和数据行；辅助索引（在聚簇索引上创建的其它索引）的叶子节点存放的是主键值或指向数据行的指针。</p>
<p>优点：根据索引可以直接获取值，所以他获取数据更快；对于主键的排序查找和范围查找效率更高；</p>
<p>缺点：如果主键值很大的话，辅助索引也会变得很大；如果用uuid作为主键，数据存储会很稀疏；修改主键或乱序插入会让数据行移动导致页分裂；所以一般我们定义主键时尽量让主键值小，并且定义为自增和不可修改。</p>
<p>非聚簇索引（辅助索引）：叶子节点存放的是数据行地址，先根据索引找到数据地址，再根据地址去找数据</p>
<p>他们都是b+数结构</p>
<h4 id="9-MySQL如何做慢SQL优化"><a href="#9-MySQL如何做慢SQL优化" class="headerlink" title="9.MySQL如何做慢SQL优化"></a>9.MySQL如何做慢SQL优化</h4><p>可以查看执行计划分析数据的扫描类型、索引是否生效，常见的慢查询优化有：</p>
<p>（1）尽量减少select的数据列，尽量使用覆盖索引</p>
<p>（2）orderby查找时使用索引进行排序，否则的话需要进行回表</p>
<p>（3）groupby查询时，同样要用索引，避免使用到临时表</p>
<p>（4）分页查询时，如果limit 后面的数字太大，可以使用子查询查出主键，再limit主键后n条数据就能走覆盖索引</p>
<p>（5） 使用复杂查询时，使用关联查询来代替子查询，并且最好使用内连接</p>
<p>（6）使用count函数时直接使用count的话count(*)的效率最高</p>
<p>count(*)或count(唯一索引)或count(数字):表中总记录数，count(字段)不会统计null</p>
<p> (7) 在写update语句时，where条件要使用索引，否则会锁会从行锁升级为表锁</p>
<p>（8）表中数据是否太大，是不是要分库分表</p>
<h4 id="10-为什么要用内连接而不用外连接？"><a href="#10-为什么要用内连接而不用外连接？" class="headerlink" title="10.为什么要用内连接而不用外连接？"></a>10.为什么要用内连接而不用外连接？</h4><p>用外连接的话连接顺序是固定死的，比如left join，他必须先对左表进行全表扫描，然后一条条到右表去匹配；而内连接的话mysql会自己根据查询优化器去判断用哪个表做驱动。</p>
<p>子查询的话同样也会对驱动表进行全表扫描，所以尽量用小表做驱动表。</p>
<h4 id="11-MySQL整个查询的过程"><a href="#11-MySQL整个查询的过程" class="headerlink" title="11.MySQL整个查询的过程"></a>11.MySQL整个查询的过程</h4><p>（1）客户端向 MySQL 服务器发送一条查询请求<br>（2）服务器首先检查查询缓存，如果命中缓存，则返回存储在缓存中的结果。否则进入下一阶段<br>（3）服务器进行 SQL 解析、预处理、再由优化器生成对应的执行计划<br>（4）MySQL 根据执行计划，调用存储引擎的 API 来执行查询<br>（5）将结果返回给客户端，同时缓存查询结果<br>注意：只有在8.0之前才有查询缓存，8.0之后查询缓存被去掉了</p>
<h4 id="12-执行计划中有哪些字段？"><a href="#12-执行计划中有哪些字段？" class="headerlink" title="12.执行计划中有哪些字段？"></a>12.执行计划中有哪些字段？</h4><p>我们想看一个sql的执行计划使用的语句是explain+SQL，表中的字段包括：</p>
<p><strong>type</strong>:扫描类型，效率从底到高为ALL（全表扫描)&gt;index(全索引扫描，我们的需要的数据在索引中可以获取)&gt;range(使用索引进行范围查找)&gt;ref(使用非唯一索引列进行了关联查询)&gt; eq_ref (使用唯一索引进行关联查询)&gt;const(使用唯一索引查询一行数据)&gt;system(表中只有一行数据)</p>
<p> <strong>extra（额外的）</strong>:mysql如何查询额外信息，常见的有：</p>
<p>filesort:在排序缓冲区中进行排序，需要回表查询数据</p>
<p>index:表示使用覆盖索引</p>
<p>index scan:排序时使用了索引排序，但如果是按照降序排序的话就会使用反向扫描索引</p>
<p>temporary:查询时要建立一个临时表存放数据</p>
<p><strong>rows</strong>:找到了多少行数据</p>
<p><strong>key</strong>:实际使用到的索引</p>
<p><strong>id</strong>:select查询的优先级，id越大优先级越高，子查询的id一般会更大</p>
<p><strong>select_type</strong>:查询的类型,是普通查询还是联合查询还是子查询，常见类型有simple（不包含子查询），primary（标记复杂查询中最外层的查询），union(标记primart只后子查询)</p>
<p><strong>table</strong>：者一行的数据是数哪张表的</p>
<p>**possible_keys（可能的）:**当前查询语句可能用到的索引，可能为null(如果用了索引但是为null有可能是表数据太少innodb认为全表扫描更快)</p>
<p>**ref（编号）:**显示索引的哪一行被使用了</p>
<h4 id="13-哪些情况索引会失效"><a href="#13-哪些情况索引会失效" class="headerlink" title="13.哪些情况索引会失效"></a>13.哪些情况索引会失效</h4><p>（1）where条件中有or，除非所有查询条件都有索引，否则失效</p>
<p>（2）like查询用%开头，索引失效</p>
<p>（3）索引列参与计算，索引失效</p>
<p>（4）违背最左匹配原则，索引失效</p>
<p>（5）索引字段发生类型转换，索引失效</p>
<p>（6）mysql觉得全表扫描更快时（数据少），索引失效</p>
<h4 id="14-B和B-数的区别，为什么使用B-数"><a href="#14-B和B-数的区别，为什么使用B-数" class="headerlink" title="14.B和B+数的区别，为什么使用B+数"></a>14.B和B+数的区别，为什么使用B+数</h4><p>二叉树：索引字段有序，极端情况会变成链表形式</p>
<p>AVL数：树的高度不可控</p>
<p>B数：控制了树的高度，但是索引值和data都分布在每个具体的节点当中，若要进行范围查询，要进行多次回溯，IO开销大</p>
<p>B+树：非叶子节点只存储索引值，叶子节点再存储索引+具体数据，从小到大用链表连接在一起，范围查询可直接遍历不需要回溯7</p>
<h4 id="15-MySQL有哪些锁"><a href="#15-MySQL有哪些锁" class="headerlink" title="15.MySQL有哪些锁"></a>15.MySQL有哪些锁</h4><p>基于粒度：</p>
<p> *表级锁：对整张表加锁，粒度大并发小</p>
<p> *行级锁：对行加锁，粒度小并发大</p>
<p> *间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读</p>
<p>基于属性：</p>
<p>  *共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁</p>
<p>   *排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题  </p>
<h4 id="16-Mysql内连接、左连接、右连接的区别"><a href="#16-Mysql内连接、左连接、右连接的区别" class="headerlink" title="16.Mysql内连接、左连接、右连接的区别"></a>16.Mysql内连接、左连接、右连接的区别</h4><p>内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分</p>
<h4 id="17-sql执行顺序"><a href="#17-sql执行顺序" class="headerlink" title="17.sql执行顺序"></a>17.sql执行顺序</h4><h4 id="18-如何设计数据库？"><a href="#18-如何设计数据库？" class="headerlink" title="18.如何设计数据库？"></a>18.如何设计数据库？</h4><p>（1）抽取实体，如用户信息，商品信息，评论</p>
<p>（2）分析其中属性，如用户信息：姓名、性别…</p>
<p>（3）分析表与表之间的关联关系</p>
<p>然后可以参考三大范式进行设计，设计主键时，主键要尽量小并且定义为自增和不可修改。</p>
<h4 id="19-where和having的区别？"><a href="#19-where和having的区别？" class="headerlink" title="19.where和having的区别？"></a>19.where和having的区别？</h4><p>where是约束声明，having是过滤声明，where早于having执行，并且where不可以使用聚合函数，having可以</p>
<h4 id="20-三大范式"><a href="#20-三大范式" class="headerlink" title="20.三大范式"></a>20.三大范式</h4><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<h4 id="21-char和varchar的区别"><a href="#21-char和varchar的区别" class="headerlink" title="21.char和varchar的区别"></a>21.char和varchar的区别</h4><p>char是不可变的，最大长度为255，varchar是可变的字符串，最大长度为2^16</p>
<h4 id="22-InnoDB-什么情况下会产生死锁"><a href="#22-InnoDB-什么情况下会产生死锁" class="headerlink" title="22.InnoDB 什么情况下会产生死锁"></a>22.InnoDB 什么情况下会产生死锁</h4><p>事务1已经获取数据A的写锁，想要去获取数据B的写锁，然后事务2获取了B的写锁，想要去获取A的写锁，相互等待形成死锁。<br>mysql解决死锁的机制有两个：1.等待， 直到超时 2.发起死锁检测，主动回滚一条事务<br>死锁检测的原理是构建一个以事务为顶点、 锁为边的有向图， 判断有向图是否存在环， 存在即有死锁。<br>我们平时尽量减少事务操作的资源和隔离级别</p>
<h4 id="23-MySQL-删除自增-id，随后重启-MySQL-服务，再插入数据，自增-id-会从几开始？"><a href="#23-MySQL-删除自增-id，随后重启-MySQL-服务，再插入数据，自增-id-会从几开始？" class="headerlink" title="23.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？"></a>23.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？</h4><p>innodb 引擎：<br>MySQL8.0前，下次自增会取表中最大 id + 1。原理是最大id会记录在内存中，重启之后会重新读取表中最大的id<br>MySQL8.0后，仍从删除数据 id 后算起。原理是它将最大id记录在redolog里了</p>
<p>myisam：<br>自增的 id 都从删除数据 id 后算起。原理是它将最大id记录到数据文件里了</p>
<h4 id="24-MySQL插入百万级的数据如何优化？"><a href="#24-MySQL插入百万级的数据如何优化？" class="headerlink" title="24.MySQL插入百万级的数据如何优化？"></a>24.MySQL插入百万级的数据如何优化？</h4><p>（1）一次sql插入多条数据，可以减少写redolog日志和binlog日志的io次数（sql是有长度限制的，但可以调整）</p>
<p>（2）保证数据按照索引进行有序插入</p>
<p>（3）可以分表后多线程插入</p>
<h3 id="五-常用开发框架系列"><a href="#五-常用开发框架系列" class="headerlink" title="五.常用开发框架系列"></a>五.常用开发框架系列</h3><h4 id="1-什么是Spring？"><a href="#1-什么是Spring？" class="headerlink" title="1.什么是Spring？"></a>1.什么是Spring？</h4><p>Spring是个轻量级的框架，通过IOC达到松耦合的目的，通过AOP可以分离应用业务逻辑和系统服务进行内聚性的开发，不过配置各种组件时比较繁琐，所以后面才出选了SpringBoot的框架。 </p>
<h4 id="2-IOC是什么？"><a href="#2-IOC是什么？" class="headerlink" title="2.IOC是什么？"></a>2.IOC是什么？</h4><p>IOC是控制反转，是一种思想，把对象的创建和调用从程序员手中交由IOC容器管理，降低对象之间的依赖关系。</p>
<p>创建一个bean的方式有xml方式、@Bean注解方式、@Componte方式</p>
<p>我们在对一个bean进行实例化后，要对他的属性进行填充，大多数我们都是使用 @Autowire直接的填充依赖注入的，他是有限按照类型进行匹配。</p>
<h4 id="3-AOP是什么？"><a href="#3-AOP是什么？" class="headerlink" title="3.AOP是什么？"></a>3.AOP是什么？</h4><p>AOP是面向切面编程，可以将那些与业务不相关但是很多业务都要调用的代码抽取出来，思想就是不侵入原有代码的情况下对功能进行增强。</p>
<p>SpringAOP是基于动态代理实现的，动态代理是有两种，一种是jdk动态代理，一种是cglib动态代理;</p>
<p>jdk动态代理是原理是利用反射来实现的，需要调用反射包下的Proxy类的newProxyInstance方法来返回代理对象，这个方法中有三个参数，分别是用于加载代理类的类加载器，被代理类实现的接口的class数组和一个用于增强方法的InvocaHandler实现类。</p>
<p>cglib动态代理原理是利用asm开源包来实现的，是把被代理类的class文件加载进来，通过修改它的字节码生成子类来处理</p>
<p>jdk动态代理要求被代理类必须有实现的接口，生成的动态代理类会和代理类实现同样的接口，cglib则，生成的动态代理类会继承被代理类。Spring默认使用jdk动态代理，当被代理的类没有接口时就使用cglib动态代理</p>
<h4 id="4-如何定义一个全局异常处理类？"><a href="#4-如何定义一个全局异常处理类？" class="headerlink" title="4.如何定义一个全局异常处理类？"></a>4.如何定义一个全局异常处理类？</h4><p>想要定义一个全局异常处理类的话，我们需要在这个类上添加@ContaollerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上添加@ExceptionHandler(value &#x3D; 异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理。</p>
<p>如果我们需要自定义异常的话，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息，再根据需求写构造方法； </p>
<h4 id="5-如何使用aop自定义日志？"><a href="#5-如何使用aop自定义日志？" class="headerlink" title="5.如何使用aop自定义日志？"></a>5.如何使用aop自定义日志？</h4><p>第一步：创建一个切面类，把它添加到ioc容器中并添加@Aspect注解</p>
<p>第二步： 在切面类中写一个通知方法，在方法上添加通知注解并通过切入点表达式来表示要对哪些方法进行日志打印，然后方法参数为JoinPoint</p>
<p>第三步：通过JoinPoint这个参数可以获取当前执行的方法名、方法参数等信息，这样就可以根据需求在方法进入或结束时打印日志</p>
<h4 id="6-循环依赖是什么，怎么解决的？"><a href="#6-循环依赖是什么，怎么解决的？" class="headerlink" title="6.循环依赖是什么，怎么解决的？"></a>6.循环依赖是什么，怎么解决的？</h4><p>循环依赖就是在创建 A 实例的时候里面包含着 B 属性实例，所以这个时候就需要去创建 B 实例，而创 建 B 实例过程中也包含着 A 实例。 这样 A 实例还在创建的过程当中，所以就导致 A 和 B 实例都创建不出来。</p>
<p>spring通过三级缓存来解决循环依赖：</p>
<p>一级缓存：单例池，缓存经过了已经初始化完毕的Bean</p>
<p>二级缓存 ：半成品池，缓存还未初始化完毕的Bean</p>
<p>三级缓存：缓存的是获取Bean的代理对象的表达式</p>
<p>我们在创建 A 的过程中，先将 A 放入三级缓存 ，这时要创建B，B要创建A就直接去三级缓存中查找，并且判断需不需要进行 AOP 处理，如果需要就在三级缓存中获取A的代理对象，不需要就取A原始对象。然后将取出的对象放入二级缓存中，这个时候其他需要依赖 A 对象的直接从二级缓存中去获取即可。当B初始化完成进入一级缓存后，A 继续执行生命周期，当A完成了属性的注入后，就可以放入一级缓存了</p>
<p>spring2.6之前默认会解决循环依赖。在spring2.6之后需要通过配置开启解决循环依赖</p>
<h4 id="7-Bean-的作用域"><a href="#7-Bean-的作用域" class="headerlink" title="7.Bean 的作用域"></a>7.Bean 的作用域</h4><p>（1）Singleton:一个IOC容器只有一个</p>
<p>（2）Prototype:每次调用getBean()都会生成一个新的对象</p>
<p>（3）request:每个http请求都会创建一个自己的bean</p>
<p>（4）session:同一个session共享一个实例</p>
<p>（5）application:整个serverContext只有一个bean</p>
<p>（6）webSocket:一个websocket只有一个bean</p>
<h4 id="8-Bean-生命周期"><a href="#8-Bean-生命周期" class="headerlink" title="8.Bean 生命周期"></a>8.Bean 生命周期</h4><p>实例化 Instantiation-&gt;属性赋值 Populate-&gt;初始化 Initialization-&gt;销毁 Destruction<br>在这四步的基础上面，Spring 提供了一些拓展点：</p>
<p>*Bean 自身的方法: 包括了 Bean 本身调用的方法和通过配置文件中的 init-method 和 destroy-method 指定的方法<br>*Bean 级生命周期接口方法:包括了 BeanNameAware、BeanFactoryAware、InitializingBean 和 DiposableBean 这些接口的方法<br>*容器级生命周期接口方法:包括了 InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。<br>*工厂后处理器接口方法: 包括了 AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer 等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p>
<h4 id="9-Spring-事务原理？"><a href="#9-Spring-事务原理？" class="headerlink" title="9.Spring 事务原理？"></a>9.Spring 事务原理？</h4><p>spring事务有编程式和声明式，我们一般使用声明式，在某个方法上增加@Transactional注解，这个方法中的sql会统一成功或失败。</p>
<p>原理是：</p>
<p>当一个方法加上@Transactional注解，spring会基于这个类生成一个代理对象并将这个代理对象作为bean，当使用这个bean中的方法时，如果存在@Transactional注解，就会将事务自动提交设为false，然后执行方法，执行过程没有异常则提交，有异常则回滚、</p>
<h4 id="10-spring事务失效场景"><a href="#10-spring事务失效场景" class="headerlink" title="10.spring事务失效场景"></a>10.spring事务失效场景</h4><p>（1）事务方法所在的类没有加载到容器中</p>
<p>（2）事务方法不是public类型</p>
<p>（3）同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效</p>
<p>（4）spring事务默认只回滚运行时异常，可以用rollbackfor属性设置</p>
<p>（5）业务自己捕获了异常，事务会认为程序正常秩序</p>
<h4 id="11-spring事务的隔离级别"><a href="#11-spring事务的隔离级别" class="headerlink" title="11.spring事务的隔离级别"></a>11.spring事务的隔离级别</h4><p>default:默认级别，使用数据库自定义的隔离级别</p>
<p>其它四种隔离级别与mysql一样</p>
<h4 id="12-spring事务的传播行为"><a href="#12-spring事务的传播行为" class="headerlink" title="12.spring事务的传播行为"></a>12.spring事务的传播行为</h4><p>（1）支持当前事务，如果不存在，则新启一个事务</p>
<p>（2）支持当前事务，如果不存在，则抛出异常</p>
<p>（3）支持当前事务，如果不存在，则以非事务方式执行</p>
<p>（4）不支持当前事务，创建一个新事物</p>
<p>（5）不支持当前事务，如果已存在事务就抛异常</p>
<p>（6）不支持当前事务，始终以非事务方式执行</p>
<h4 id="13-Spring-IoC"><a href="#13-Spring-IoC" class="headerlink" title="13.Spring IoC"></a>13.Spring IoC</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200904160557786.png" alt="20200904160557786.png"></p>
<h4 id="12-spring用了哪些设计模式"><a href="#12-spring用了哪些设计模式" class="headerlink" title="12.spring用了哪些设计模式"></a>12.spring用了哪些设计模式</h4><p>BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式</p>
<h4 id="14-SpringMV工作原理"><a href="#14-SpringMV工作原理" class="headerlink" title="14.SpringMV工作原理"></a>14.SpringMV工作原理</h4><p>SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）</p>
<p>工作流程：</p>
<p>（1）DispatchServerlet接收用户请求将请求发送给HandleMapping</p>
<p> （2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet</p>
<p>（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler</p>
<p>（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view</p>
<p>（5）DispatchServerlet根据view进行视图渲染，返回给用户</p>
<h4 id="15-springboot自动配置原理"><a href="#15-springboot自动配置原理" class="headerlink" title="15.springboot自动配置原理"></a>15.springboot自动配置原理</h4><p>在spring—boot—autoconfigura包下存放了spring内置的自动配置类和spring.factories文件，这个文件中存放了这些配置类的全类名 ；</p>
<p>启动类@SpringbootApplication注解下，有三个关键注解</p>
<p>（1）@springbootConfiguration:表示启动类是一个自动配置类</p>
<p>（2）@CompontScan:扫描启动类所在包下及子包的组件到容器中</p>
<p>（3）@EnableConfigutarion，下面有个子注解@Import会导入上面所说的自动配置类，这些配置类会根据元注解的装配条件生效，生效的类就会被实例化，加载到ioc容器中；这些自动配置类还会通过xxxProperties文件里配置来进行属性设值</p>
<h4 id="16-springboot常用注解"><a href="#16-springboot常用注解" class="headerlink" title="16 .springboot常用注解"></a>16 .springboot常用注解</h4><p>@RestController          ：修饰类，该控制器会返回Json数据 </p>
<p>@RequestMapping(“&#x2F;path”) ：修饰类，该控制器的请求路径</p>
<p>@Autowired             :  修饰属性，按照类型进行依赖注入</p>
<p>@PathVariable           :  修饰参数，将路径值映射到参数上</p>
<p>@ResponseBody         :修饰方法，该方法会返回Json数据</p>
<p>@RequestBody（需要使用Post提交方式） :修饰参数，将Json数据封装到对应参数中<br>@Controller@Service@Compont:  将类注册到ioc容器</p>
<p>@Transaction：开启事务</p>
<h4 id="17-spring的bean是线程安全的吗？"><a href="#17-spring的bean是线程安全的吗？" class="headerlink" title="17.spring的bean是线程安全的吗？"></a>17.spring的bean是线程安全的吗？</h4><p>spring的默认bean作用域是单例的，单例的bean不是线程安全的，但是开发中大部分的bean都是无状态的，不具备存储功能，比如controller、service、dao，他们不需要保证线程安全。</p>
<p>如果要保证线程安全，可以将bean的作用域改为prototype，比如像Model View。</p>
<p>另外还可以采用<strong>ThreadLocal</strong>来解决线程安全问题。ThreadLocal为每个线程保存一个副本变量，每个线程只操作自己的副本变量。</p>
<h4 id="18-springcloud主要解决什么问题？"><a href="#18-springcloud主要解决什么问题？" class="headerlink" title="18.springcloud主要解决什么问题？"></a>18.springcloud主要解决什么问题？</h4><p>解决服务之间的通信、容灾、负载平衡、冗余问题，能方便服务集中管理，常用组件有注册中心、配置中心、远程调用。服务熔断、网关</p>
<h4 id="19-CAP理论"><a href="#19-CAP理论" class="headerlink" title="19.CAP理论"></a>19.CAP理论</h4><p>C：一致性，这里指的强一致性，也就是数据更新完，访问任何节点看到的数据完全一致</p>
<p>A：可用性，就是任何没有发生故障的服务必须在规定时间内返回合正确结果</p>
<p>P：容灾性，当网络不稳定时节点之间无法通信，造成分区，这时要保证系统可以继续正常服务。提高容灾性的办法就是把数据分配到每一个节点当中，所以P是分布式系统必须实现的，然后需要在C和A中取舍</p>
<h4 id="20-为什么不能同时保证一致性和可用性呢？"><a href="#20-为什么不能同时保证一致性和可用性呢？" class="headerlink" title="20.为什么不能同时保证一致性和可用性呢？"></a>20.为什么不能同时保证一致性和可用性呢？</h4><p>当网络发生故障时，如果要保障数据一致性，那么节点相互间就只能阻塞等待数据真正同步时再返回，就违背可用性了。如果要保证可用性，节点要在有限时间内将结果返回，无法等待其它节点的更新消息，此时返回的数据可能就不是最新数据，就违背了一致性了</p>
<h4 id="21-熔断限流的理解？"><a href="#21-熔断限流的理解？" class="headerlink" title="21.熔断限流的理解？"></a>21.熔断限流的理解？</h4><p>SprngCloud中用Hystrix组件来进行降级、熔断、限流</p>
<p>熔断是对于消费者来讲，当对提供者请求时间过久时为了不影响性能就对链接进行熔断，</p>
<p>限流是对于提供者来讲，为了防止某个消费者流量太大，导致其它更重要的消费者请求无法及时处理。限流可用通过拒绝服务、服务降级、消息队列延时处理、限流算法来实现</p>
<h4 id="22-常用限流算法"><a href="#22-常用限流算法" class="headerlink" title="22.常用限流算法"></a>22.常用限流算法</h4><p>计数器算法：使用redis的setnx和过期机制实现</p>
<p>漏桶算法：一般使用消息队列来实现，系统以恒定速度处理队列中的请求，当队列满的时候开始拒绝请求。</p>
<p>令牌桶算法：计数器算法和漏桶算法都无法解决突然的大并发，令牌桶算法是预先往桶中放入一定数量token，然后用恒定速度放入token直到桶满为止，所有请求都必须拿到token才能访问系统</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="六-Redis系列"><a href="#六-Redis系列" class="headerlink" title="六.Redis系列"></a>六.Redis系列</h3><h4 id="1-redis为什么快？"><a href="#1-redis为什么快？" class="headerlink" title="1.redis为什么快？"></a>1.redis为什么快？</h4><p>（1）完全基于内存操作</p>
<p>（2）数据结构简单，对数据操作简单</p>
<p>（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题</p>
<p> (4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器</p>
<p>其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。</p>
<h4 id="2-redis持久化机制"><a href="#2-redis持久化机制" class="headerlink" title="2.redis持久化机制"></a>2.redis持久化机制</h4><p>（1）快照持久化RDB</p>
<p>redis的默认持久化机制，通过父进程fork一个子进程，子进程将redis的数据快照写入一个临时文件，等待持久化完毕后替换上一次的rdb文件。整个过程主进程不进行任何的io操作。持久化策略可以通过save配置单位时间内执行多少次操作触发持久化。所以RDB的优点是保证redis性能最大化，恢复速度数据较快，缺点是可能会丢失两次持久化之间的数据</p>
<p>（2）追加持久化AOF</p>
<p>以日志形式记录每一次的写入和删除操作，策略有每秒同步、每次操作同步、不同步，优点是数据完整性高，缺点是运行效率低，恢复时间长</p>
<h4 id="3-Redis如何实现key的过期删除？"><a href="#3-Redis如何实现key的过期删除？" class="headerlink" title="3.Redis如何实现key的过期删除？"></a>3.Redis如何实现key的过期删除？</h4><p>采用的定期过期+惰性过期</p>
<p>定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。<br>惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。</p>
<h4 id="4-Redis数据类型应用场景"><a href="#4-Redis数据类型应用场景" class="headerlink" title="4.Redis数据类型应用场景"></a>4.Redis数据类型应用场景</h4><p>String：可以用来缓存json信息，可以用incr命令实现自增或自减的计数器</p>
<p>Hash：与String一样可以保存json信息</p>
<p>List：可以用来做消息队列，list的pop是原子性操作能一定程度保证线程安全</p>
<p>Set：可以做去重，比如一个用户只能参加一次活动 ;可以做交集求共友</p>
<p>SortSet ：有序的。可以实现排行榜</p>
<h4 id="5-Redis缓存穿透如何解决？"><a href="#5-Redis缓存穿透如何解决？" class="headerlink" title="5.Redis缓存穿透如何解决？"></a>5.Redis缓存穿透如何解决？</h4><p>缓存穿透是指频繁请求客户端和缓存中都不存在的数据，缓存永远不生效，请求都到达了数据库。</p>
<p>解决方案：</p>
<p>（1）在接口上做基础校验，比如id&lt;&#x3D;0就拦截</p>
<p>（2）缓存空对象：找不到的数据也缓存起来，并设置过期时间，可能会造成短期不一致</p>
<p>（3）布隆过滤器：在客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求</p>
<h4 id="6-Redis如何解决缓存击穿？"><a href="#6-Redis如何解决缓存击穿？" class="headerlink" title="6.Redis如何解决缓存击穿？"></a>6.Redis如何解决缓存击穿？</h4><p>缓存击穿是值一个key非常热点，key在某一瞬间失效，导致大量请求到达数据库</p>
<p>解决方案：</p>
<p>（1）设置热点数据永不过期</p>
<p>（2）给缓存重建的业务加上互斥锁，缺点是性能低</p>
<h4 id="7-Redis如何解决缓存雪崩？"><a href="#7-Redis如何解决缓存雪崩？" class="headerlink" title="7.Redis如何解决缓存雪崩？"></a>7.Redis如何解决缓存雪崩？</h4><p>缓存雪崩是值某一时间Key同时失效或redis宕机，导致大量请求到达数据库</p>
<p>解决方案：</p>
<p>（1）搭建集群保证高可用</p>
<p>（2）进行数据预热，给不同的key设置随机的过期时间</p>
<p>（3）给缓存业务添加限流降级，通过加锁或队列控制操作redis的线程数量</p>
<p>（4）给业务添加多级缓存</p>
<h4 id="8-Redis分布式锁的实现原理"><a href="#8-Redis分布式锁的实现原理" class="headerlink" title="8.Redis分布式锁的实现原理"></a>8.Redis分布式锁的实现原理</h4><p>原理是使用setnx+setex命令来实现，但是会有一系列问题：</p>
<p>（1）任务时常超过缓存时间，锁自动释放。可以使用Redision看门狗解决</p>
<p>（2）加锁和释放锁的不是同一线程。可以在Value中存入uuid，删除时进行验证。但是要注意验证锁和删除锁也不是一个原子性操作，可以用lua脚本使之成为原子性操作</p>
<p>（3）不可重入。可以使用Redision解决（实现机制类似AQS,计数）</p>
<p>（4）redis集群下主节点宕机导致锁丢失。使用红锁解决</p>
<h4 id="9-Redis集群方案"><a href="#9-Redis集群方案" class="headerlink" title="9.Redis集群方案"></a>9.Redis集群方案</h4><p>(1)主从模式：个master节点，多个slave节点，master节点宕机slave自动变成主节点</p>
<p>(2)哨兵模式：在主从集群基础上添加哨兵节点或哨兵集群，用于监控master节点健康状态，通过投票机制选择slave成为主节点</p>
<p>(3)分片集群：主从模式和哨兵模式解决了并发读的问题，但没有解决并发写的问题，因此有了分片集群。分片集群有多个master节点并且不同master保存不同的数据，master之间通过ping相互监测健康状态。客户端请求任意一个节点都会转发到正确节点，因为每个master都被映射到0-16384个插槽上，集群的key是根据key的hash值与插槽绑定</p>
<h4 id="10-Redis集群主从同步原理"><a href="#10-Redis集群主从同步原理" class="headerlink" title="10.Redis集群主从同步原理"></a>10.Redis集群主从同步原理</h4><p>主从同步第一次是全量同步：slave第一次请求master节点会根据replid判断是否是第一次同步，是的话master会生成RDB发送给slave。</p>
<p>后续为增量同步：在发送RDB期间，会产生一个缓存区间记录发送RDB期间产生的新的命令,slave节点在加载完后，会持续读取缓存区间中的数据</p>
<h4 id="11-Redis缓存一致性解决方案"><a href="#11-Redis缓存一致性解决方案" class="headerlink" title="11.Redis缓存一致性解决方案"></a>11.Redis缓存一致性解决方案</h4><p>Redis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序</p>
<p>先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。</p>
<p>先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。</p>
<p>但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。</p>
<h4 id="12-Redis内存淘汰策略"><a href="#12-Redis内存淘汰策略" class="headerlink" title="12.Redis内存淘汰策略"></a>12.Redis内存淘汰策略</h4><p>当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的</p>
<h3 id="七-计算机网络系列"><a href="#七-计算机网络系列" class="headerlink" title="七.计算机网络系列"></a>七.计算机网络系列</h3><h4 id="1-TCP-IP模型"><a href="#1-TCP-IP模型" class="headerlink" title="1.TCP&#x2F;IP模型"></a>1.TCP&#x2F;IP模型<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200904160558176.png" alt="20200904160558176.png"></h4><h4 id="2-浏览器输入地址后做了什么？"><a href="#2-浏览器输入地址后做了什么？" class="headerlink" title="2.浏览器输入地址后做了什么？"></a>2.浏览器输入地址后做了什么？</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200904160558322.png" alt="20200904160558322.png"></p>
<h4 id="3-TCP三次握手"><a href="#3-TCP三次握手" class="headerlink" title="3.TCP三次握手"></a>3.TCP三次握手</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200904160558436.png" alt="20200904160558436.png"></p>
<h4 id="4-为什么TCP不能两次握手"><a href="#4-为什么TCP不能两次握手" class="headerlink" title="4.为什么TCP不能两次握手"></a>4.为什么TCP不能两次握手</h4><p>假设是两次握手，若客户端发起的连接请求阻塞在网络中，会造成该报文的重传，这时服务收到连接请求后会立刻进入连接状态，当双方传输完数据结束连接后，第一次阻塞的请求突然又到达了服务端，此时服务端又进入连接状态，而客户端不会响应服务端的连接确认报文</p>
<h4 id="5-TCP四次挥手"><a href="#5-TCP四次挥手" class="headerlink" title="5.TCP四次挥手"></a>5.TCP四次挥手</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200904160558691.png" alt="20200904160558691.png"></p>
<h4 id="6-为什么要进入时间等待状态？"><a href="#6-为什么要进入时间等待状态？" class="headerlink" title="6.为什么要进入时间等待状态？"></a>6.为什么要进入时间等待状态？</h4><p>若客户端发送确认释放包后直接关闭，而服务端因为某种原因没有收到客户端的确认释放包，就会一直发送确认请求，而客户端永远不会再响应该请求。</p>
<h4 id="7-TCP-滑动窗口"><a href="#7-TCP-滑动窗口" class="headerlink" title="7.TCP 滑动窗口"></a>7.TCP 滑动窗口</h4><p>TCP 流量控制，主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。如果TCP发送方收到接收方的零窗口通知后，会启动持续计时器。计时器超时后向接收方发送零窗口探测报文，如果响应仍为0，就重新计时，不为0就打破死锁</p>
<h4 id="8-TCP拥塞控制"><a href="#8-TCP拥塞控制" class="headerlink" title="8.TCP拥塞控制"></a>8.TCP拥塞控制</h4><p>发送方会维护一个拥塞窗口大小的状态变量，大小取决于网络的拥塞程度。发送方的发送窗口大小是取接收方接收窗口和拥塞窗口中较小的一个</p>
<p>拥塞控制有四种算法：</p>
<p>慢开始：从小到大主键发送窗口，每收到一个确认报文窗口大小指数增长</p>
<p>拥塞避免：当窗口大小到达一定阈值时，转为拥塞避免，每收到一个确认报文窗口大小+1。若此时网络超时，就把阈值调小一半，重新慢开始</p>
<p>快重传：要求接收方收到请求后要立即回复</p>
<p>快恢复：发送方连续收到多个确认时，就把拥塞避免阈值减小，然后直接开始拥塞避免</p>
<h4 id="9-TCP超时重传"><a href="#9-TCP超时重传" class="headerlink" title="9.TCP超时重传"></a>9.TCP超时重传</h4><p>发送方在发送按数据后一定时间内没有收到接收方响应报文，就会重新发送刚刚的报文，接收到收到报文后会对该报文的序列号进行检验，已存在就抛弃</p>
<h4 id="10-TCP可靠传输的实现"><a href="#10-TCP可靠传输的实现" class="headerlink" title="10.TCP可靠传输的实现"></a>10.TCP可靠传输的实现</h4><p>TCP是靠滑动窗口协议和连续ARQ协议配合流量控制和拥塞控制来保证的可靠传输。</p>
<p>ARQ是停止等待协议和自动重传请求，它规定TCP要为每一次传输的包编号，每发送一个包，要等待对方确认后才能发送下一个分组，若一段时间对方没有确认，就重新发送刚刚的报文。接收方会对数据包排序，把有序数据传给应用层，返回缺失的第一个ACK确认序列号给发送方,接收到收到报文后会对该报文的序列号进行检验，重复就丢弃。</p>
<p>流量控制是…..拥塞窗口上……（上面已经说了）</p>
<h4 id="11-TCP报头有哪些信息"><a href="#11-TCP报头有哪些信息" class="headerlink" title="11.TCP报头有哪些信息"></a>11.TCP报头有哪些信息</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20181129174610446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjczNjAyNA==,size_16,color_FFFFFF,t_70" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjczNjAyNA==,size_16,color_FFFFFF,t_70"></p>
<h4 id="12-状态码"><a href="#12-状态码" class="headerlink" title="12.状态码"></a>12.状态码</h4><p>1xx:请求正在处理</p>
<p>2xx:请求成功处理</p>
<p>3xx:请求重定向  301：永久重定向   302：临时重定向    304：使用本地缓存</p>
<p>4xx:客户端错误  400：请求格式错误  403：没有访问权限  415：请求体过大</p>
<p>5xx:服务端错误</p>
<h4 id="13-http与https的区别"><a href="#13-http与https的区别" class="headerlink" title="13.http与https的区别"></a>13.http与https的区别</h4><h4 id="14-socket通信流程"><a href="#14-socket通信流程" class="headerlink" title="14.socket通信流程"></a>14.socket通信流程</h4><p>（1）服务端创建socket并调用bind()方法绑定ip和端口号</p>
<p>（2）服务端调用listen()方法建立监听，此时服务的scoket还没有打开</p>
<p>（3）客户端创建socket并调用connect()方法像服务端请求连接</p>
<p>（4）服务端socket监听到客户端请求后，被动打开，调用accept()方法接收客户端连接请求，当accept()方法接收到客户端connect()方法返回的响应成功的信息后，连接成功</p>
<p>（5）客户端向socket写入请求信息，服务端读取信息</p>
<p>（6）客户端调用close()结束链接，服务端监听到释放连接请求后，也结束链接</p>
<h3 id="八-linux系列"><a href="#八-linux系列" class="headerlink" title="八.linux系列"></a>八.linux系列</h3><h4 id="1-linux常用命令"><a href="#1-linux常用命令" class="headerlink" title="1.linux常用命令"></a>1.linux常用命令</h4><p>ifconfig:查看网络接口详情</p>
<p>ping：查看与某主机是否能联通</p>
<p>ps -ef|grep 进程名称：查看进程号</p>
<p>lost -i 端口 ：查看端口占用情况</p>
<p>top:查看系统负载情况，包括系统时间、系统所有进程状态、cpu情况</p>
<p>free:查看内存占用情况</p>
<p>kill:正常杀死进程，发出的信号可能会被阻塞</p>
<p>kill -9:强制杀死进程，发送的是exit命令，不会被阻塞</p>
<h4 id="2-linux的io模型"><a href="#2-linux的io模型" class="headerlink" title="2.linux的io模型"></a>2.linux的io模型</h4><p>IO是对磁盘或网络数据的读写，用户进程读取一次IO请求分为两个阶段：等待数据到达内核缓冲区和将内核缓冲区数据拷贝到用户空间，当用户去内核中拷贝数据时，要从用户态转为核心态</p>
<p>5中io模型:</p>
<p>(1)同步阻塞IO模型</p>
<p>用户进程发起io调用后会被阻塞，等待内核缓冲区数据准备完毕时就被唤醒，将内核数据复制到用户进程。这两个阶段都是阻塞的</p>
<p>(2)同步非阻塞IO模型</p>
<p>用户进程发起IO调用后，若内核缓冲区数据还未准备好，进程会继续干别的事，每隔一段时间就去看看内核数据是否准备好。不过将内核数据复制到用户进程这个阶段依旧是阻塞的</p>
<p>(3)IO多路复用模型</p>
<p>linux中把一切都看成文件，每个文件都有一个文件描述符（FD）来关联， IO多路复用模型就是复用单个进程同时监测多个文件描述符，当某个文件描述符可读或可写，就去通知用户进程。</p>
<p>(4)信号IO模型</p>
<p>用户进程发起IO调用后，会向内核注册一个信号处理函数然后继续干别的事，当内核数据准备就绪时就通知用户进程来进行拷贝。</p>
<p>（5）异步非阻塞模型</p>
<p>前面四种全是同步的。进程在发起IO调用后，会直接返回结果。待内核数据准备好时，由内核将数据复制给用户进程。两个阶段都是非阻塞的</p>
<h4 id="4-IO多路复用详解"><a href="#4-IO多路复用详解" class="headerlink" title="4.IO多路复用详解"></a>4.IO多路复用详解</h4><p>linux中把一切都看成文件，每个文件都有一个文件描述符（FD）来关联， IO多路复用模型就是复用单个进程同时监测多个文件描述符，当某个文件描述符可读或可写，就去通知用户进程。IO多路复用有三种方式</p>
<p>（1）select：采用数组结构，监测的fd有限，默认为1024；当有文件描述符就绪时，需要遍历整个FD数组来查看是哪个文件描述符就绪了，效率较低；每次调用select时都需要把整个文件描述符数组从用户态拷贝到内核态中来回拷贝，当fd很多时开销会很大；</p>
<p>（2）poll：采用链表结构，监测的文件描述符没有上限，其它的根select差不多</p>
<p>（3）epoll：采用红黑树结构，监测的fd没有上限，它有三个方法，epoll_create() 用于创建一个epoll实例，epoll实例中有一颗红黑树记录监测的fd，一个链表记录就绪的fd;epoll_ctl() 用于往epoll实例中增删要监测的文件描述符，并设置回调函数，当文件描述符就绪时触发回调函数将文件描述符添加到就绪链表当中；epoll_wait() 用于见擦汗就绪列表并返回就绪列表的长度，然后将就绪列表的拷贝到用户空间缓冲区中。</p>
<p>所以epoll的优点是当有文件描述符就绪时，只把已就绪的文件描述符写给用户空间，不需要每次都遍历FD集合；每个FD只有在调新增的时候和就绪的时候才会在用户空间和内核空间之间拷贝一次。</p>
<h4 id="5-epoll的LT和ET模式"><a href="#5-epoll的LT和ET模式" class="headerlink" title="5.epoll的LT和ET模式"></a>5.epoll的LT和ET模式</h4><p>LT（默认）：水平触发，当FD有数据可读的时候，那么每次 epoll_wait都会去通知用户来操作直到读完</p>
<p>ET：边缘触发，当FD有数据可读的时候，它只会通知用户一次，直到下次再有数据流入才会再通知，所以在ET模式下一定要把缓冲区的数据一次读完</p>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/ali.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/ali.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/09/04/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%8D%83%E9%97%AE/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=后端八股千问&amp;url=http://example.com/2023/09/04/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%8D%83%E9%97%AE/&amp;pic=https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E7%B2%89.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/1.4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/09/04/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%8D%83%E9%97%AE/">原创</a><a class="post-copyright-title"><span>后端八股千问</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="http://example.com">Charles</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="http://example.com/2023/09/04/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%8D%83%E9%97%AE/">http://example.com/2023/09/04/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%8D%83%E9%97%AE/</a></span><span class="copy-button" onclick="rm.copyPageUrl('http://example.com/2023/09/04/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%8D%83%E9%97%AE/')"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">荒岛</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/03/12SpringBootWeb%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E5%A4%A7%E5%91%80.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Springboot笔记-12SpringBootWeb登录认证</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/04/13SpringBootWeb%20AOP/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Springboot笔记-13-SpringBootWeb AOP</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"><a class="avatar-img" href="/about"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></a></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name">Charles</h1><div class="author-info__description">记录自己技术的成长过程</div><div class="banner-button-group"><a class="banner-button" onclick="pjax.loadUrl(&quot;/about/&quot;)"><span class="banner-button-text">了解更多</span><i class="anzhiyufont anzhiyu-icon-arrow-circle-right" style="font-size: 1.5rem"></i></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://gitee.com/Charles_Coder" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1483323316@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/353796337" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/face.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://pic-1318156172.cos.ap-beijing.myqcloud.com/pay/back.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">三、高并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JAVA%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.0.1.</span> <span class="toc-text">一、JAVA基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1.接口和抽象类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">2.重载和重写的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">3.&#x3D;&#x3D;和equals的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">4.异常处理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-HashMap%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">5.HashMap原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%83%B3%E8%A6%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">6.想要线程安全的HashMap怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-ConcurrentHashMap%E5%8E%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">7.ConcurrentHashMap原如何保证的线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-HashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.8.</span> <span class="toc-text">8.HashTable与HashMap的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.9.</span> <span class="toc-text">9.ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81ArrayList%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.0.1.10.</span> <span class="toc-text">10.如何保证ArrayList的线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.11.</span> <span class="toc-text">11.String、StringBuffer、StringBuilder的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-hashCode%E5%92%8Cequals"><span class="toc-number">1.0.1.12.</span> <span class="toc-text">12.hashCode和equals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.13.</span> <span class="toc-text">13.面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.1.14.</span> <span class="toc-text">4.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.0.1.15.</span> <span class="toc-text">15.多态的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">1.0.1.16.</span> <span class="toc-text">16.什么是反射？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%BE%97%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.1.17.</span> <span class="toc-text">17.Java创建对象得五种方式?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87"><span class="toc-number">1.0.2.</span> <span class="toc-text">二.Java多线程篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">1.进程和线程的区别，进程间如何通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">2. 什么是线程上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">3.什么是死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">4.死锁的必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Synchrpnized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">5.Synchrpnized和lock的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AFAQS%E9%94%81"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">6.什么是AQS锁?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84AQS%E9%94%81"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">8.有哪些常见的AQS锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-yield-%E5%92%8Cjoin-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.2.8.</span> <span class="toc-text">10.yield()和join()区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.2.9.</span> <span class="toc-text">11.线程池七大参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.2.10.</span> <span class="toc-text">12.Java内存模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.0.2.11.</span> <span class="toc-text">13.保证并发安全的三大特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-volatile"><span class="toc-number">1.0.2.12.</span> <span class="toc-text">14.volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.2.13.</span> <span class="toc-text">15.线程使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.2.14.</span> <span class="toc-text">16.ThreadLocal原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E4%BB%80%E4%B9%88%E6%98%AFCAS%E9%94%81"><span class="toc-number">1.0.2.15.</span> <span class="toc-text">17.什么是CAS锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-Synchronized%E9%94%81%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.2.16.</span> <span class="toc-text">18.Synchronized锁原理和优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE-CPU-%E6%A0%B8%E5%BF%83%E6%95%B0%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="toc-number">1.0.2.17.</span> <span class="toc-text">19.如何根据 CPU 核心数设计线程池线程数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-AtomicInteger%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.2.18.</span> <span class="toc-text">20.AtomicInteger的使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-JVM%E7%AF%87"><span class="toc-number">1.0.3.</span> <span class="toc-text">三.JVM篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">1.JVM运行时数据区（内存结构）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">2.什么情况下会内存溢出？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">3.JVM有哪些垃圾回收算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">4.GC如何判断对象可以被回收？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%85%B8%E5%9E%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">5.典型垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.3.6.</span> <span class="toc-text">6.类加载器和双亲委派机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-JVM%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">1.0.3.7.</span> <span class="toc-text">7.JVM中有哪些引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.3.8.</span> <span class="toc-text">8.类加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-JVM%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.0.3.9.</span> <span class="toc-text">9.JVM类初始化顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.3.10.</span> <span class="toc-text">10..对象的创建过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.0.3.11.</span> <span class="toc-text">11.对象头中有哪些信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-JVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.3.12.</span> <span class="toc-text">12.JVM内存参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-GC%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.3.13.</span> <span class="toc-text">13.GC的回收机制和原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-Mysql%E7%AF%87"><span class="toc-number">1.0.4.</span> <span class="toc-text">四.Mysql篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-MyIsAm%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">1.MyIsAm和InnoDB的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mysql%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">2.mysql事务特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">3.事务靠什么保证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">4.事务的隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">5.什么是快照读和当前读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-MVCC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.0.4.6.</span> <span class="toc-text">6.MVCC是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.0.4.7.</span> <span class="toc-text">7.MySQL有哪些索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.4.8.</span> <span class="toc-text">8.聚簇索引和非聚簇索引的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-MySQL%E5%A6%82%E4%BD%95%E5%81%9A%E6%85%A2SQL%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.4.9.</span> <span class="toc-text">9.MySQL如何做慢SQL优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%86%85%E8%BF%9E%E6%8E%A5%E8%80%8C%E4%B8%8D%E7%94%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">1.0.4.10.</span> <span class="toc-text">10.为什么要用内连接而不用外连接？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-MySQL%E6%95%B4%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.4.11.</span> <span class="toc-text">11.MySQL整个查询的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">1.0.4.12.</span> <span class="toc-text">12.执行计划中有哪些字段？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">1.0.4.13.</span> <span class="toc-text">13.哪些情况索引会失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-B%E5%92%8CB-%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%95%B0"><span class="toc-number">1.0.4.14.</span> <span class="toc-text">14.B和B+数的区别，为什么使用B+数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81"><span class="toc-number">1.0.4.15.</span> <span class="toc-text">15.MySQL有哪些锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-Mysql%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.4.16.</span> <span class="toc-text">16.Mysql内连接、左连接、右连接的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.0.4.17.</span> <span class="toc-text">17.sql执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">1.0.4.18.</span> <span class="toc-text">18.如何设计数据库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-where%E5%92%8Chaving%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.4.19.</span> <span class="toc-text">19.where和having的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.0.4.20.</span> <span class="toc-text">20.三大范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-char%E5%92%8Cvarchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.4.21.</span> <span class="toc-text">21.char和varchar的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-InnoDB-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-number">1.0.4.22.</span> <span class="toc-text">22.InnoDB 什么情况下会产生死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-MySQL-%E5%88%A0%E9%99%A4%E8%87%AA%E5%A2%9E-id%EF%BC%8C%E9%9A%8F%E5%90%8E%E9%87%8D%E5%90%AF-MySQL-%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%86%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%87%AA%E5%A2%9E-id-%E4%BC%9A%E4%BB%8E%E5%87%A0%E5%BC%80%E5%A7%8B%EF%BC%9F"><span class="toc-number">1.0.4.23.</span> <span class="toc-text">23.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-MySQL%E6%8F%92%E5%85%A5%E7%99%BE%E4%B8%87%E7%BA%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.0.4.24.</span> <span class="toc-text">24.MySQL插入百万级的数据如何优化？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97"><span class="toc-number">1.0.5.</span> <span class="toc-text">五.常用开发框架系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFSpring%EF%BC%9F"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">1.什么是Spring？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-IOC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">2.IOC是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-AOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">3.AOP是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">4.如何定义一个全局异常处理类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8aop%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">5.如何使用aop自定义日志？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.5.6.</span> <span class="toc-text">6.循环依赖是什么，怎么解决的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.0.5.7.</span> <span class="toc-text">7.Bean 的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.0.5.8.</span> <span class="toc-text">8.Bean 生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Spring-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.0.5.9.</span> <span class="toc-text">9.Spring 事务原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.5.10.</span> <span class="toc-text">10.spring事务失效场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.0.5.11.</span> <span class="toc-text">11.spring事务的隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.0.5.12.</span> <span class="toc-text">12.spring事务的传播行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-Spring-IoC"><span class="toc-number">1.0.5.13.</span> <span class="toc-text">13.Spring IoC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-spring%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.5.14.</span> <span class="toc-text">12.spring用了哪些设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-SpringMV%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.5.15.</span> <span class="toc-text">14.SpringMV工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.5.16.</span> <span class="toc-text">15.springboot自动配置原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.0.5.17.</span> <span class="toc-text">16 .springboot常用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-spring%E7%9A%84bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.5.18.</span> <span class="toc-text">17.spring的bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-springcloud%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.0.5.19.</span> <span class="toc-text">18.springcloud主要解决什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-CAP%E7%90%86%E8%AE%BA"><span class="toc-number">1.0.5.20.</span> <span class="toc-text">19.CAP理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="toc-number">1.0.5.21.</span> <span class="toc-text">20.为什么不能同时保证一致性和可用性呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.0.5.22.</span> <span class="toc-text">21.熔断限流的理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.5.23.</span> <span class="toc-text">22.常用限流算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.0.5.24.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-Redis%E7%B3%BB%E5%88%97"><span class="toc-number">1.0.6.</span> <span class="toc-text">六.Redis系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">1.redis为什么快？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">2.redis持久化机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0key%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">3.Redis如何实现key的过期删除？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">4.Redis数据类型应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">5.Redis缓存穿透如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Redis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F"><span class="toc-number">1.0.6.6.</span> <span class="toc-text">6.Redis如何解决缓存击穿？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Redis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-number">1.0.6.7.</span> <span class="toc-text">7.Redis如何解决缓存雪崩？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.6.8.</span> <span class="toc-text">8.Redis分布式锁的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">1.0.6.9.</span> <span class="toc-text">9.Redis集群方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Redis%E9%9B%86%E7%BE%A4%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.6.10.</span> <span class="toc-text">10.Redis集群主从同步原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.0.6.11.</span> <span class="toc-text">11.Redis缓存一致性解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.6.12.</span> <span class="toc-text">12.Redis内存淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97"><span class="toc-number">1.0.7.</span> <span class="toc-text">七.计算机网络系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-TCP-IP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">1.TCP&#x2F;IP模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%90%8E%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">2.浏览器输入地址后做了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">3.TCP三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E4%B8%8D%E8%83%BD%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">4.为什么TCP不能两次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.0.7.5.</span> <span class="toc-text">5.TCP四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E5%85%A5%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.0.7.6.</span> <span class="toc-text">6.为什么要进入时间等待状态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.0.7.7.</span> <span class="toc-text">7.TCP 滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.0.7.8.</span> <span class="toc-text">8.TCP拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">1.0.7.9.</span> <span class="toc-text">9.TCP超时重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.7.10.</span> <span class="toc-text">10.TCP可靠传输的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-TCP%E6%8A%A5%E5%A4%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.0.7.11.</span> <span class="toc-text">11.TCP报头有哪些信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.0.7.12.</span> <span class="toc-text">12.状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.7.13.</span> <span class="toc-text">13.http与https的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-socket%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.7.14.</span> <span class="toc-text">14.socket通信流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-linux%E7%B3%BB%E5%88%97"><span class="toc-number">1.0.8.</span> <span class="toc-text">八.linux系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">1.linux常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-linux%E7%9A%84io%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">2.linux的io模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">4.IO多路复用详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-epoll%E7%9A%84LT%E5%92%8CET%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">5.epoll的LT和ET模式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/17/%E4%BF%A1%E5%AE%89%E6%A6%82%E8%AE%BA/" title="信安概论纪要"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/1.4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信安概论纪要"/></a><div class="content"><a class="title" href="/2024/11/17/%E4%BF%A1%E5%AE%89%E6%A6%82%E8%AE%BA/" title="信安概论纪要">信安概论纪要</a><time datetime="2024-11-17T02:38:19.000Z" title="发表于 2024-11-17 10:38:19">2024-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/13/React%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/" title="React学习手册"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E7%BA%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React学习手册"/></a><div class="content"><a class="title" href="/2024/10/13/React%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/" title="React学习手册">React学习手册</a><time datetime="2024-10-13T14:59:08.000Z" title="发表于 2024-10-13 22:59:08">2024-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/22/2024-06-22-WebPack/" title="WebPack"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E7%BA%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebPack"/></a><div class="content"><a class="title" href="/2024/06/22/2024-06-22-WebPack/" title="WebPack">WebPack</a><time datetime="2024-06-22T02:39:41.000Z" title="发表于 2024-06-22 10:39:41">2024-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/14/2024-4-14-%E4%BB%BF%E6%B7%98%E5%AE%9D%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" title="仿淘宝项目总结笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E8%BF%B7%E5%9F%8E.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="仿淘宝项目总结笔记"/></a><div class="content"><a class="title" href="/2024/04/14/2024-4-14-%E4%BB%BF%E6%B7%98%E5%AE%9D%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" title="仿淘宝项目总结笔记">仿淘宝项目总结笔记</a><time datetime="2024-04-14T02:39:41.000Z" title="发表于 2024-04-14 10:39:41">2024-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/17/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%93%E9%A2%98/" title="超级详尽的内存管理知识"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/%E7%BA%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="超级详尽的内存管理知识"/></a><div class="content"><a class="title" href="/2023/09/17/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%93%E9%A2%98/" title="超级详尽的内存管理知识">超级详尽的内存管理知识</a><time datetime="2023-09-17T02:39:41.000Z" title="发表于 2023-09-17 10:39:41">2023-09-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:anzhiyu-c@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/6378063631" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.facebook.com/profile.php?id=100092208016287&amp;sk=about" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><img class="footer_mini_logo" title="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/avater.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/Charles-coder" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/353796337" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://v.douyin.com" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" target="_blank" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" href="https://butterfly.zhheo.com/Introduction.html#%E9%AD%94%E6%94%B9%E6%95%88%E6%9E%9C">源码</a><a class="footer-item" title="更新日志" target="_blank" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" target="_blank" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" target="_blank" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" target="_blank" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" target="_blank" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" target="_blank" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" target="_blank" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><div class="copyright">&copy;2020 - 2024 By Charles</div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://butterfly.zhheo.com/Introduction.html#%E9%AD%94%E6%94%B9%E6%95%88%E6%9E%9C" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-1318156172.cos.ap-beijing.myqcloud.com/cover/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-127px;"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-127px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch_commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>转为繁体</span></a></div></div><div id="rightmenu-mask"></div><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@17.3.1/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 1.4.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Charles 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://npm.elemecdn.com/algoliasearch@4.14.2/dist/algoliasearch-lite.umd.js"></script><script src="https://npm.elemecdn.com/instantsearch.js@4.46.1/dist/instantsearch.production.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/search/algolia.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'zHdOBOB3J11nYjY9dnLxOdrU-MdYXbMMI',
      appKey: '9ZUUTt1oh6fLPuj1aSvLUD5y',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://npm.elemecdn.com/valine@1.5.1/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://npm.elemecdn.com/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://zHdOBOB3.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'zHdOBOB3J11nYjY9dnLxOdrU-MdYXbMMI',
        "X-LC-Key": '9ZUUTt1oh6fLPuj1aSvLUD5y',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";</script><script>//动态标题
let leaveTitle = 'w(ﾟДﾟ)w 不要走！再看看嘛！';
let backTitle = '♪(^∇^*)欢迎肥来！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | 荒岛")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();
anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.4/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div></body></html>